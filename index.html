<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TransLoom — AI Translation Workbench</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Sans:ital,opsz,wght@0,9..40,300..700;1,9..40,300..700&family=JetBrains+Mono:wght@400;500&family=Noto+Serif:wght@400;500;600;700&family=Noto+Sans:wght@400;500;600;700&family=Lora:wght@400;500;600;700&family=Merriweather:wght@400;700&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/mammoth@1.8.0/mammoth.browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/docx@9.1.1/build/index.umd.min.js"></script>
<script src="https://js.puter.com/v2/"></script>
<script>
tailwind.config = {
  theme: {
    extend: {
      fontFamily: {
        serif: ['Instrument Serif', 'Georgia', 'serif'],
        sans: ['DM Sans', 'system-ui', 'sans-serif'],
        mono: ['JetBrains Mono', 'monospace'],
      },
      colors: {
        ink: { 50:'#fafaf9', 100:'#f5f5f4', 200:'#e7e5e4', 300:'#d6d3d1', 400:'#a8a29e', 500:'#78716c', 600:'#57534e', 700:'#44403c', 800:'#292524', 900:'#1c1917' },
        accent: { DEFAULT:'#2563eb', light:'#dbeafe', dark:'#1d4ed8' },
      }
    }
  }
}
</script>
<style>
* { box-sizing: border-box; }
body { font-family: 'DM Sans', system-ui, sans-serif; background: #fafaf9; color: #292524; margin: 0; }

.page-texture::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  opacity: 0.25;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.04'/%3E%3C/svg%3E");
  z-index: 9999;
}

::-webkit-scrollbar { width: 5px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: #d6d3d1; border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: #a8a29e; }

.upload-zone {
  border: 2px dashed #d6d3d1;
  transition: all 0.25s ease;
  background: repeating-linear-gradient(-45deg, transparent, transparent 10px, rgba(0,0,0,0.008) 10px, rgba(0,0,0,0.008) 20px);
}
.upload-zone:hover, .upload-zone.dragover { border-color: #2563eb; background: #dbeafe; }

.phase-enter { animation: phaseIn 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
@keyframes phaseIn { from { opacity: 0; transform: translateY(16px); } to { opacity: 1; transform: translateY(0); } }

.toast { animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s; animation-fill-mode: forwards; }
@keyframes toastIn { from { opacity: 0; transform: translateY(16px); } to { opacity: 1; transform: translateY(0); } }
@keyframes toastOut { from { opacity: 1; } to { opacity: 0; } }

.modal-backdrop { background: rgba(28,25,23,0.4); backdrop-filter: blur(4px); }
.modal-content { animation: modalIn 0.25s cubic-bezier(0.4,0,0.2,1); }
@keyframes modalIn { from { opacity: 0; transform: scale(0.96) translateY(8px); } to { opacity: 1; transform: scale(1) translateY(0); } }

.seg-item { transition: all 0.2s ease; border-left: 3px solid transparent; }
.seg-item:hover { background: #f5f5f4; }
.seg-item.active { border-left-color: #2563eb; background: #eff6ff; }
.seg-item.completed { border-left-color: #34d399; }
.seg-item.needs-review { border-left-color: #f59e0b; }
.seg-item.ready { border-left-color: #a855f7; }

.chapter-group { border-bottom: 1px solid #f5f5f4; }
.chapter-header { cursor: pointer; user-select: none; transition: background 0.15s ease; position: sticky; top: 0; z-index: 10; background: white; }
.chapter-header:hover { background: #f5f5f4; }
.chapter-header .chevron { transition: transform 0.2s ease; }
.chapter-header.collapsed .chevron { transform: rotate(-90deg); }
.chapter-body { transition: max-height 0.25s ease; overflow: hidden; }
.chapter-body.collapsed { max-height: 0 !important; }

.sidebar-tab { padding: 6px 12px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #78716c; border-bottom: 2px solid transparent; cursor: pointer; transition: all 0.15s ease; white-space: nowrap; }
.sidebar-tab:hover { color: #292524; }
.sidebar-tab.active { color: #2563eb; border-bottom-color: #2563eb; }

.copy-btn { opacity: 0; transition: opacity 0.15s ease; }
.option-card:hover .copy-btn { opacity: 1; }
.copy-btn.copied { opacity: 1; color: #059669; }

.progress-seg { flex: 1; height: 100%; border-radius: 2px; background: #e7e5e4; transition: background 0.3s ease; }
.progress-seg.done { background: #34d399; }
.progress-seg.current { background: #2563eb; }

.option-card { border: 2px solid #e7e5e4; transition: all 0.2s ease; cursor: pointer; }
.option-card:hover { border-color: #d6d3d1; box-shadow: 0 2px 8px rgba(0,0,0,0.04); }
.option-card.selected { border-color: #2563eb; background: #eff6ff; box-shadow: 0 0 0 3px rgba(37,99,235,0.1); }

.btn-primary { background: #292524; color: white; transition: all 0.2s ease; font-weight: 500; }
.btn-primary:hover { background: #1c1917; transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
.btn-accent { background: #2563eb; color: white; transition: all 0.2s ease; font-weight: 500; }
.btn-accent:hover { background: #1d4ed8; }
.btn-accent:disabled { background: #93c5fd; cursor: not-allowed; }
.btn-secondary { background: white; color: #292524; border: 1px solid #e7e5e4; transition: all 0.2s ease; }
.btn-secondary:hover { border-color: #d6d3d1; background: #fafaf9; }
.btn-green { background: #059669; color: white; transition: all 0.2s ease; }
.btn-green:hover { background: #047857; }
.btn-red { background: #dc2626; color: white; transition: all 0.2s ease; }
.btn-red:hover { background: #b91c1c; }

.spinner { animation: spin 1s linear infinite; }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

.loading-dots span { animation: dotPulse 1.4s infinite ease-in-out both; }
.loading-dots span:nth-child(1) { animation-delay: -0.32s; }
.loading-dots span:nth-child(2) { animation-delay: -0.16s; }
@keyframes dotPulse { 0%, 80%, 100% { opacity: 0.3; } 40% { opacity: 1; } }

.popup-editor { animation: popupIn 0.2s ease; box-shadow: 0 8px 32px rgba(0,0,0,0.18); }
@keyframes popupIn { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }

.editor-para { transition: outline 0.15s ease, background 0.15s ease; cursor: pointer; padding: 4px 2px; border-radius: 4px; }
.editor-para:hover { background: rgba(37,99,235,0.03); }
.editor-para.selected-para { outline: 2px solid #2563eb; outline-offset: 2px; background: rgba(37,99,235,0.04); }
.typo-align.selected { background: #2563eb !important; color: white !important; border-color: #2563eb !important; }

.diff-del { background: #fef2f2; color: #991b1b; text-decoration: line-through; padding: 1px 2px; border-radius: 2px; }
.diff-ins { background: #f0fdf4; color: #166534; padding: 1px 2px; border-radius: 2px; }

.batch-toast {
  position: fixed;
  bottom: 80px;
  right: 24px;
  z-index: 90;
  width: 280px;
  background: white;
  border: 1px solid #e7e5e4;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.12);
  padding: 12px 16px;
  animation: toastIn 0.3s ease;
}
.batch-toast.dismissing {
  animation: toastOut 0.3s ease forwards;
}

.glossary-float-btn {
  animation: popupIn 0.15s ease;
}
</style>
</head>
<body class="page-texture min-h-screen">

<!-- Toast Container -->
<div id="toast-container" class="fixed bottom-6 right-6 z-[100] flex flex-col gap-2"></div>

<!-- Keyboard Shortcuts Panel -->
<div id="shortcuts-panel" class="hidden fixed inset-0 z-[95] modal-backdrop flex items-center justify-center p-4" onclick="if(event.target===this)toggleShortcutsPanel()">
  <div class="modal-content bg-white rounded-2xl border border-ink-200 shadow-xl max-w-md w-full p-6 space-y-4">
    <div class="flex items-center justify-between">
      <h3 class="font-serif text-xl text-ink-900 italic">Keyboard Shortcuts</h3>
      <button onclick="toggleShortcutsPanel()" class="text-ink-400 hover:text-ink-600"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg></button>
    </div>
    <div class="space-y-1">
      <p class="text-[10px] uppercase tracking-wider text-ink-400 font-semibold mb-2">Translation Workbench</p>
      <div class="grid grid-cols-[auto_1fr] gap-x-4 gap-y-1.5 text-sm">
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">1</kbd><span class="text-ink-600">Select Faithful translation</span>
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">2</kbd><span class="text-ink-600">Select Natural translation</span>
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">3</kbd><span class="text-ink-600">Select Creative translation</span>
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">Enter</kbd><span class="text-ink-600">Confirm & next segment</span>
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">&larr;</kbd><span class="text-ink-600">Previous segment</span>
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">&rarr;</kbd><span class="text-ink-600">Next segment</span>
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">R</kbd><span class="text-ink-600">Regenerate translations</span>
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">W</kbd><span class="text-ink-600">Write your own</span>
      </div>
    </div>
    <div class="space-y-1">
      <p class="text-[10px] uppercase tracking-wider text-ink-400 font-semibold mb-2">General</p>
      <div class="grid grid-cols-[auto_1fr] gap-x-4 gap-y-1.5 text-sm">
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">Ctrl+S</kbd><span class="text-ink-600">Save progress</span>
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">Esc</kbd><span class="text-ink-600">Close panel / popup</span>
        <kbd class="px-1.5 py-0.5 rounded bg-ink-100 border border-ink-200 text-ink-600 font-mono text-xs">Ctrl+/</kbd><span class="text-ink-600">Toggle this panel</span>
      </div>
    </div>
    <p class="text-[10px] text-ink-300 text-center pt-2">Press <kbd class="px-1 py-0.5 rounded bg-ink-100 border border-ink-200 font-mono text-[10px]">Ctrl+/</kbd> anytime to show/hide</p>
  </div>
</div>

<!-- Shortcut Hint (shown briefly on Phase 2 load) -->
<div id="shortcuts-hint" class="hidden fixed bottom-6 left-6 z-[90] bg-ink-800 text-white px-3 py-2 rounded-lg text-xs shadow-lg flex items-center gap-2 toast">
  <kbd class="px-1 py-0.5 rounded bg-ink-600 border border-ink-500 font-mono text-[10px]">Ctrl+/</kbd>
  <span>Keyboard shortcuts</span>
</div>

<!-- ========== PHASE 1: PROJECT CREATION ========== -->
<div id="phase1" class="min-h-screen flex items-center justify-center p-4 phase-enter">
  <div class="max-w-xl w-full">
    <div class="text-center mb-8">
      <h1 class="font-serif text-6xl text-ink-900 italic mb-2">TransLoom</h1>
      <p class="text-ink-400 text-sm tracking-widest uppercase">AI Translation Workbench</p>
    </div>

    <div class="bg-white rounded-2xl border border-ink-200 p-6 space-y-5 shadow-sm">
      <!-- File Upload -->
      <div>
        <label class="block text-xs uppercase tracking-wider text-ink-400 mb-2 font-medium">Document</label>
        <div id="drop-zone" class="upload-zone rounded-xl p-8 text-center cursor-pointer" onclick="document.getElementById('file-input').click()">
          <svg class="w-10 h-10 mx-auto text-ink-300 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/></svg>
          <p class="text-ink-600 font-medium text-sm mb-1">Drop your document here</p>
          <p class="text-ink-400 text-xs mb-3">Supports TXT, DOCX, EPUB</p>
          <div class="flex gap-1.5 justify-center flex-wrap">
            <span class="text-[10px] px-2 py-0.5 rounded bg-ink-100 text-ink-500 border border-ink-200">.txt</span>
            <span class="text-[10px] px-2 py-0.5 rounded bg-ink-100 text-ink-500 border border-ink-200">.docx</span>
            <span class="text-[10px] px-2 py-0.5 rounded bg-ink-100 text-ink-500 border border-ink-200">.epub</span>
          </div>
          <input type="file" id="file-input" accept=".txt,.docx,.epub" class="hidden">
        </div>
        <p id="file-name-display" class="text-xs text-ink-400 mt-2 hidden"></p>
      </div>

      <!-- Project Name -->
      <div>
        <label class="block text-xs uppercase tracking-wider text-ink-400 mb-2 font-medium">Project Name</label>
        <input type="text" id="project-name" class="w-full px-3 py-2.5 rounded-lg border border-ink-200 text-sm focus:outline-none focus:border-accent focus:ring-2 focus:ring-accent/10" placeholder="My Translation Project">
      </div>

      <!-- Progress File (Optional) -->
      <div>
        <label class="block text-xs uppercase tracking-wider text-ink-400 mb-2 font-medium">Resume Progress <span class="text-ink-300 normal-case tracking-normal">(optional)</span></label>
        <div id="progress-drop-zone" class="upload-zone rounded-xl p-4 text-center cursor-pointer" onclick="document.getElementById('progress-file-input').click()" style="border-style:dashed;border-width:1.5px;">
          <div class="flex items-center justify-center gap-2">
            <svg class="w-5 h-5 text-ink-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/></svg>
            <p class="text-ink-500 text-xs">Drop <span class="font-mono text-ink-600">.tlprog</span> file to restore previous session</p>
          </div>
          <input type="file" id="progress-file-input" accept=".tlprog" class="hidden">
        </div>
        <p id="progress-file-display" class="text-xs text-ink-400 mt-1.5 hidden flex items-center gap-1.5">
          <svg class="w-3.5 h-3.5 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/></svg>
          <span id="progress-file-name"></span>
          <button onclick="clearProgressFile(event)" class="text-ink-400 hover:text-red-500 ml-1">&times;</button>
        </p>
        <!-- Resume directly from progress file (no book needed) -->
        <div id="progress-resume-direct" class="hidden mt-2 p-3 bg-green-50 border border-green-200 rounded-xl">
          <p class="text-xs text-green-700 mb-2">This progress file contains full source text. You can resume directly without re-uploading the book.</p>
          <button id="resume-direct-btn" onclick="resumeFromProgressOnly()" class="btn-accent w-full py-2 rounded-lg text-xs font-medium flex items-center justify-center gap-1.5">
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
            Resume Directly (skip book upload)
          </button>
        </div>
      </div>

      <!-- Language Selection -->
      <div class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-xs uppercase tracking-wider text-ink-400 mb-2 font-medium">Source Language</label>
          <select id="source-lang" class="w-full px-3 py-2.5 rounded-lg border border-ink-200 text-sm focus:outline-none focus:border-accent bg-white"></select>
        </div>
        <div>
          <label class="block text-xs uppercase tracking-wider text-ink-400 mb-2 font-medium">Target Language</label>
          <select id="target-lang" class="w-full px-3 py-2.5 rounded-lg border border-ink-200 text-sm focus:outline-none focus:border-accent bg-white"></select>
        </div>
      </div>

      <!-- Model Selection -->
      <div>
        <label class="block text-xs uppercase tracking-wider text-ink-400 mb-2 font-medium">AI Model</label>
        <select id="model-select" class="w-full px-3 py-2.5 rounded-lg border border-ink-200 text-sm focus:outline-none focus:border-accent bg-white"></select>
        <div id="p1-premium-unlock" class="mt-1.5">
          <span id="p1-unlock-link" class="text-[11px] text-ink-400 underline cursor-pointer hover:text-accent transition-colors" onclick="toggleP1UnlockBox()">Unlock Premium Models</span>
          <div id="p1-unlock-box" class="hidden mt-1.5 flex items-center gap-1.5">
            <input type="text" id="p1-premium-code" class="flex-1 px-2.5 py-1.5 rounded-lg border border-ink-200 text-xs font-mono focus:outline-none focus:border-accent placeholder:text-ink-300" placeholder="Enter code" autocomplete="off" spellcheck="false" onkeydown="if(event.key==='Enter')activatePremiumFrom('p1')">
            <button onclick="activatePremiumFrom('p1')" class="p-1.5 rounded-lg border border-ink-200 hover:bg-accent hover:text-white hover:border-accent text-ink-400 transition-colors" title="Activate">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg>
            </button>
          </div>
          <div id="p1-premium-active" class="hidden mt-1 flex items-center gap-1.5">
            <span class="text-[10px] px-2 py-0.5 rounded-full bg-accent text-white font-medium">Premium Active</span>
          </div>
        </div>
      </div>

      <!-- Manual Copy/Paste Mode (only visible after premium unlock) -->
      <div id="p1-manual-mode-option" class="hidden">
        <label class="flex items-center gap-2.5 cursor-pointer select-none group">
          <input type="checkbox" id="p1-manual-toggle" class="w-4 h-4 rounded border-ink-300 text-amber-500 focus:ring-amber-400 cursor-pointer" onchange="toggleP1ManualMode()">
          <div>
            <span class="text-xs font-medium text-ink-700 group-hover:text-ink-900 transition-colors">Manual Copy/Paste Mode</span>
            <p class="text-[10px] text-ink-400 mt-0.5">Skip AI — copy prompts to your own AI tool, paste translations back. No tokens used.</p>
          </div>
        </label>
      </div>

      <!-- Create Button -->
      <button id="create-btn" class="btn-accent w-full py-3 rounded-xl text-sm font-medium" disabled>
        Create Project
      </button>
      <p id="create-status" class="text-xs text-ink-400 text-center hidden"></p>
    </div>

    <!-- Restore Session -->
    <div id="restore-banner" class="hidden mt-4 p-4 bg-white rounded-xl border border-ink-200 text-center">
      <p class="text-ink-500 text-sm mb-2">A previous project was found.</p>
      <div class="flex gap-2 justify-center">
        <button id="restore-btn" class="btn-accent px-4 py-1.5 rounded-lg text-sm">Resume Project</button>
        <button id="discard-btn" class="btn-secondary px-4 py-1.5 rounded-lg text-sm">Start Fresh</button>
      </div>
    </div>
  </div>
</div>

<!-- ========== PHASE 2: TRANSLATION WORKBENCH ========== -->
<div id="phase2" class="hidden h-screen flex flex-col overflow-hidden">
  <!-- Top Bar -->
  <header class="bg-white border-b border-ink-200 px-4 py-2.5 flex items-center justify-between shrink-0">
    <div class="flex items-center gap-2 min-w-0">
      <h1 class="font-serif text-xl text-ink-900 italic cursor-pointer shrink-0" onclick="goToPhase(1)">TransLoom</h1>
      <span class="text-ink-300 shrink-0">/</span>
      <span id="p2-project-name" class="text-sm text-ink-600 font-medium truncate max-w-[180px]"></span>
      <span class="text-ink-300 shrink-0">/</span>
      <span id="p2-lang-badge" class="text-xs text-ink-400 shrink-0 whitespace-nowrap"></span>
    </div>
    <div class="flex items-center gap-2 shrink-0">
      <button onclick="exportProgress()" class="btn-secondary px-3 py-1.5 rounded-lg text-xs flex items-center gap-1.5" title="Save Progress">
        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"/></svg>
        Save
      </button>
      <div class="relative" id="prefs-dropdown-container">
        <button onclick="togglePrefsDropdown()" class="btn-secondary px-3 py-1.5 rounded-lg text-xs flex items-center gap-1.5" title="Language Preferences">
          <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"/></svg>
          Prefs
          <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
        </button>
        <div id="prefs-dropdown" class="hidden absolute right-0 top-full mt-1 bg-white border border-ink-200 rounded-lg shadow-lg py-1 z-20 min-w-[160px]">
          <button onclick="exportPreferences();togglePrefsDropdown()" class="w-full text-left px-3 py-1.5 text-xs hover:bg-ink-50 flex items-center gap-2">
            <svg class="w-3 h-3 text-ink-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
            Export Preferences
          </button>
          <label class="w-full text-left px-3 py-1.5 text-xs hover:bg-ink-50 flex items-center gap-2 cursor-pointer">
            <svg class="w-3 h-3 text-ink-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m4-8l-4-4m0 0L16 8m4-4v12"/></svg>
            Import Preferences
            <input type="file" accept=".json" onchange="importPreferences(event);togglePrefsDropdown()" class="hidden">
          </label>
        </div>
      </div>
      <button id="go-to-editor-btn" class="btn-accent px-3 py-1.5 rounded-lg text-xs hidden">Open Editor</button>
      <button onclick="toggleSettingsPanel()" class="btn-secondary px-3 py-1.5 rounded-lg text-xs flex items-center gap-1.5" id="settings-toggle-btn">
        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.066 2.573c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.573 1.066c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.066-2.573c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><circle cx="12" cy="12" r="3"/></svg>
        Settings
      </button>
    </div>
  </header>

  <!-- Settings Panel (hidden by default) -->
  <div id="settings-panel" class="hidden border-b border-ink-200 bg-ink-50">
    <div class="max-w-2xl mx-auto px-6 py-4 space-y-4">
      <div class="flex items-center justify-between">
        <span class="text-xs uppercase tracking-wider text-ink-400 font-semibold">Project Settings</span>
        <button onclick="toggleSettingsPanel()" class="text-ink-400 hover:text-ink-600"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg></button>
      </div>
      <div class="grid grid-cols-2 gap-4">
        <!-- AI Model -->
        <div>
          <label class="block text-xs text-ink-500 mb-1 font-medium">AI Model</label>
          <select id="settings-model" class="w-full px-3 py-2 rounded-lg border border-ink-200 text-sm bg-white focus:outline-none focus:border-accent" onchange="updateProjectModel()"></select>
        </div>
        <!-- Account Type -->
        <div>
          <label class="block text-xs text-ink-500 mb-1 font-medium">Account</label>
          <div id="premium-status-area">
            <!-- Dynamically rendered by populateSettingsPanel -->
          </div>
        </div>
      </div>
      <!-- AI Provider Settings -->
      <div class="flex items-center justify-between py-2 px-3 rounded-lg border border-ink-200 bg-white">
        <div class="flex-1 space-y-2">
          <div>
            <span class="text-sm text-ink-700 font-medium">AI Provider</span>
            <p class="text-[10px] text-ink-400 mt-0.5">Falls back automatically if Puter.js is unavailable.</p>
          </div>
          <div class="grid grid-cols-2 gap-3">
            <div>
              <label class="block text-[10px] text-ink-500 mb-0.5 font-medium">Provider</label>
              <select id="settings-ai-provider" class="w-full px-2.5 py-1.5 rounded-lg border border-ink-200 text-xs bg-white focus:outline-none focus:border-accent" onchange="onProviderChange()">
                <option value="puter">Puter.js (default)</option>
                <option value="openai">OpenAI API</option>
                <option value="anthropic">Anthropic API</option>
                <option value="manual">Manual Only (No AI)</option>
              </select>
            </div>
            <div id="api-key-field" class="hidden">
              <label class="block text-[10px] text-ink-500 mb-0.5 font-medium">API Key</label>
              <input type="password" id="settings-api-key" class="w-full px-2.5 py-1.5 rounded-lg border border-ink-200 text-xs bg-white focus:outline-none focus:border-accent font-mono" placeholder="sk-...">
            </div>
          </div>
          <div id="api-key-actions" class="hidden flex items-center gap-2">
            <button onclick="testApiKey()" class="btn-secondary px-2.5 py-1 rounded-lg text-[10px] font-medium">Test Connection</button>
            <span id="api-test-result" class="text-[10px] text-ink-400"></span>
          </div>
        </div>
      </div>
      <!-- Code Unlock -->
      <div class="flex items-center justify-between py-2 px-3 rounded-lg border border-ink-200 bg-white">
        <div>
          <span class="text-sm text-ink-700 font-medium">Code Unlock</span>
          <p class="text-[10px] text-ink-400 mt-0.5">Skip to the editor at any time, even if not all segments are translated.</p>
        </div>
        <label class="relative inline-flex items-center cursor-pointer">
          <input type="checkbox" id="settings-code-unlock" class="sr-only peer" onchange="toggleCodeUnlock()">
          <div class="w-9 h-5 bg-ink-200 peer-focus:ring-2 peer-focus:ring-accent/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-ink-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-accent"></div>
        </label>
      </div>
      <!-- Clear Session Data -->
      <div class="flex items-center justify-between py-2 px-3 rounded-lg border border-red-200 bg-red-50/50">
        <div>
          <span class="text-sm text-ink-700 font-medium">Clear All Session Data</span>
          <p class="text-[10px] text-ink-400 mt-0.5">Removes premium code, preferences, and all locally cached settings. You will need to re-enter your code.</p>
        </div>
        <button onclick="clearAllSessionData()" class="px-3 py-1.5 rounded-lg text-[10px] font-medium border border-red-300 text-red-600 hover:bg-red-100 transition-colors whitespace-nowrap">Clear Data</button>
      </div>
      <div class="flex justify-end">
        <button onclick="saveSettings()" class="btn-accent px-4 py-2 rounded-lg text-xs font-medium">Save Settings</button>
      </div>
    </div>
  </div>

  <!-- Two Panel Layout -->
  <div class="flex-1 flex overflow-hidden">
    <!-- Left Sidebar -->
    <div id="p2-sidebar" class="w-[30%] min-w-[260px] border-r border-ink-200 bg-white flex flex-col">
      <div class="px-4 py-3 border-b border-ink-100 shrink-0">
        <div class="flex items-center justify-between mb-2">
          <span class="text-xs uppercase tracking-wider text-ink-400 font-medium">Progress</span>
          <span id="p2-progress-text" class="text-xs font-semibold text-ink-500">0%</span>
        </div>
        <div id="p2-progress-bar" class="flex gap-0.5 h-1.5 rounded overflow-hidden"></div>
      </div>
      <!-- Sidebar Tabs -->
      <div class="flex border-b border-ink-100 shrink-0 px-2 gap-1">
        <div class="sidebar-tab active" data-sidebar-tab="segments" onclick="switchSidebarTab('segments')">Segments</div>
        <div class="sidebar-tab" data-sidebar-tab="translated" onclick="switchSidebarTab('translated')">Translated</div>
        <div class="sidebar-tab" data-sidebar-tab="glossary" onclick="switchSidebarTab('glossary')">Glossary</div>
      </div>
      <div id="p2-segment-list" class="flex-1 overflow-y-auto"></div>
      <div id="p2-translated-list" class="flex-1 overflow-y-auto hidden"></div>
      <div id="p2-glossary-panel" class="flex-1 overflow-y-auto hidden">
        <div class="p-4 space-y-3">
          <div class="flex items-center justify-between">
            <span class="text-[10px] uppercase tracking-wider text-ink-400 font-semibold">Term Glossary</span>
            <div class="flex items-center gap-1.5">
              <button onclick="exportGlossary()" class="text-[10px] text-ink-400 hover:text-accent transition-colors inline-flex items-center" title="Export">Export</button>
              <span class="text-ink-300 text-[10px]">|</span>
              <label class="text-[10px] text-ink-400 hover:text-accent transition-colors cursor-pointer inline-flex items-center" title="Import">
                Import
                <input type="file" accept=".json,.tlgloss" onchange="importGlossary(event)" class="hidden">
              </label>
            </div>
          </div>
          <div class="flex gap-1.5">
            <input type="text" id="glossary-source" class="flex-1 px-2 py-1.5 rounded-lg border border-ink-200 text-xs focus:outline-none focus:border-accent" placeholder="Source term">
            <input type="text" id="glossary-target" class="flex-1 px-2 py-1.5 rounded-lg border border-ink-200 text-xs focus:outline-none focus:border-accent" placeholder="Translation">
            <button onclick="addGlossaryEntry()" class="btn-accent px-2 py-1.5 rounded-lg text-[10px] font-medium whitespace-nowrap">Add</button>
          </div>
          <div id="glossary-entries" class="space-y-1"></div>
          <p id="glossary-empty" class="text-xs text-ink-400 text-center py-4">No glossary entries yet. Add terms to ensure consistent translation.</p>
        </div>
      </div>
    </div>

    <!-- Right Main Area -->
    <div id="p2-main" class="flex-1 flex flex-col overflow-hidden bg-ink-50">
      <!-- Segment Navigation -->
      <div class="px-6 py-3 bg-white border-b border-ink-100 flex items-center justify-between shrink-0">
        <button id="prev-seg-btn" class="btn-secondary px-3 py-1.5 rounded-lg text-xs flex items-center gap-1" disabled>
          <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
          Previous
        </button>
        <span id="p2-seg-counter" class="text-sm font-medium text-ink-600"></span>
        <button id="next-seg-btn" class="btn-secondary px-3 py-1.5 rounded-lg text-xs flex items-center gap-1" disabled>
          Next
          <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
        </button>
      </div>

      <!-- Content Area (scrollable) -->
      <div class="flex-1 overflow-y-auto p-6 space-y-5">
        <!-- Source Text -->
        <div id="p2-source-card" class="bg-white rounded-xl border border-ink-200 p-5">
          <div class="flex items-center gap-2 mb-3">
            <span class="text-[10px] uppercase tracking-wider text-ink-400 font-semibold">Original</span>
            <span id="p2-source-lang-tag" class="text-[10px] px-1.5 py-0.5 rounded bg-ink-100 text-ink-500"></span>
          </div>
          <div id="p2-source-text" class="text-ink-800 leading-relaxed" style="font-size:15px;"></div>
        </div>

        <!-- Translation Options -->
        <div id="p2-options-area">
          <!-- Loading State -->
          <div id="p2-loading" class="hidden flex flex-col items-center gap-3 py-10">
            <div class="w-7 h-7 border-2 border-ink-200 border-t-accent rounded-full spinner"></div>
            <p class="text-ink-400 text-sm">Generating translations...</p>
          </div>
          <!-- Options Cards -->
          <div id="p2-options-list" class="space-y-3"></div>
          <!-- Write Own -->
          <div id="p2-write-own" class="hidden mt-3">
            <div class="bg-white rounded-xl border-2 border-dashed border-ink-200 p-4">
              <span class="text-[10px] uppercase tracking-wider text-ink-400 font-semibold block mb-2">Your translation</span>
              <textarea id="p2-custom-input" class="w-full text-sm text-ink-800 leading-relaxed border-none outline-none resize-none bg-transparent" rows="4" placeholder="Write your own translation..."></textarea>
            </div>
          </div>
          <!-- Manual Mode Prompt Panel -->
          <div id="p2-manual-mode" class="hidden mt-3 space-y-3">
            <div class="bg-amber-50 border border-amber-200 rounded-xl p-4">
              <div class="flex items-center gap-2 mb-2">
                <svg class="w-4 h-4 text-amber-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                <span class="text-xs font-semibold text-amber-700">Manual Mode</span>
              </div>
              <p class="text-xs text-amber-600 mb-3">Copy these prompts to use with your preferred AI. Paste the System Prompt first (once per session), then copy the Translate Prompt for each segment.</p>
              <div class="space-y-2">
                <button id="copy-system-prompt-btn" class="w-full btn-secondary px-4 py-2.5 rounded-lg text-xs font-medium flex items-center justify-center gap-2 hover:bg-amber-100 border-amber-300">
                  <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"/></svg>
                  Copy System Prompt (first message)
                </button>
                <button id="copy-translate-prompt-btn" class="w-full btn-accent px-4 py-2.5 rounded-lg text-xs font-medium flex items-center justify-center gap-2">
                  <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"/></svg>
                  Copy Translate Prompt (this segment)
                </button>
              </div>
              <div id="p2-manual-preview" class="mt-3 hidden">
                <pre class="text-[11px] text-ink-600 bg-white rounded-lg border border-ink-200 p-3 max-h-40 overflow-y-auto whitespace-pre-wrap font-mono"></pre>
              </div>
            </div>
            <div class="bg-white rounded-xl border-2 border-dashed border-ink-200 p-4">
              <span class="text-[10px] uppercase tracking-wider text-ink-400 font-semibold block mb-2">Paste your translation here</span>
              <textarea id="p2-custom-input-manual" class="w-full text-sm text-ink-800 leading-relaxed border-none outline-none resize-none bg-transparent" rows="4" placeholder="Paste the AI-generated translation here..."></textarea>
            </div>
          </div>
        </div>

        <!-- Action Bar -->
        <div id="p2-actions" class="flex flex-wrap gap-2">
          <button id="regen-btn" class="btn-secondary px-3 py-2 rounded-lg text-xs flex items-center gap-1.5">
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
            Regenerate
          </button>
          <button id="regen-instruct-btn" class="btn-secondary px-3 py-2 rounded-lg text-xs flex items-center gap-1.5">
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/></svg>
            Regenerate with Instructions
          </button>
          <button id="compare-btn" class="btn-secondary px-3 py-2 rounded-lg text-xs flex items-center gap-1.5 hidden">
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/></svg>
            Compare with Previous
          </button>
          <button id="write-own-btn" class="btn-secondary px-3 py-2 rounded-lg text-xs flex items-center gap-1.5">
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg>
            Write My Own
          </button>
          <div class="w-full"></div>
          <button id="batch-5-btn" class="btn-accent px-3 py-2 rounded-lg text-xs flex items-center gap-1.5">
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"/></svg>
            Translate Next 5
          </button>
          <button id="batch-10-btn" class="btn-secondary px-3 py-2 rounded-lg text-xs flex items-center gap-1.5">
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"/></svg>
            Translate Next 10
          </button>
        </div>

        <!-- Batch Progress (rendered as floating toast via JS) -->

        <!-- Instruction Input (hidden by default) -->
        <div id="p2-instruct-area" class="hidden">
          <div class="bg-white rounded-xl border border-ink-200 p-4">
            <label class="block text-[10px] uppercase tracking-wider text-ink-400 font-semibold mb-2">Additional Instructions</label>
            <textarea id="p2-instruct-input" class="w-full text-sm border border-ink-200 rounded-lg p-3 focus:outline-none focus:border-accent resize-none" rows="2" placeholder="e.g. More formal tone, use shorter sentences..."></textarea>
            <button id="p2-instruct-go" class="btn-accent px-4 py-2 rounded-lg text-xs mt-2">Generate with Instructions</button>
          </div>
        </div>

        <!-- Compare Area (hidden by default) -->
        <div id="p2-compare-area" class="hidden">
          <div class="bg-white rounded-xl border border-ink-200 p-4">
            <span class="text-[10px] uppercase tracking-wider text-ink-400 font-semibold block mb-3">Previous vs Current</span>
            <div id="p2-compare-content" class="space-y-2 text-sm"></div>
          </div>
        </div>
      </div>

      <!-- Confirm Button -->
      <div class="px-6 py-4 bg-white border-t border-ink-200 shrink-0">
        <button id="confirm-btn" class="btn-accent w-full py-3 rounded-xl text-sm font-medium" disabled>
          Confirm & Next
        </button>
      </div>
    </div>
  </div>
</div>

<!-- ========== PHASE 3: FULL BOOK EDITOR ========== -->
<div id="phase3" class="hidden h-screen flex flex-col overflow-hidden">
  <!-- Primary Header -->
  <header class="bg-white border-b border-ink-200 shrink-0">
    <div class="px-4 py-2.5 flex items-center justify-between">
      <div class="flex items-center gap-3">
        <h1 class="font-serif text-xl text-ink-900 italic cursor-pointer" onclick="goToPhase(1)">TransLoom</h1>
        <span class="text-ink-300">|</span>
        <span id="p3-project-name" class="text-sm text-ink-600 font-medium"></span>
        <span class="text-ink-300">|</span>
        <span class="text-xs text-ink-400">Editor</span>
      </div>
      <div class="flex items-center gap-2">
        <button onclick="exportProgress()" class="btn-secondary px-3 py-1.5 rounded-lg text-xs flex items-center gap-1.5" title="Save Progress">
          <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"/></svg>
          Save
        </button>
        <div class="relative" id="p3-prefs-dropdown-container">
          <button onclick="togglePrefsDropdown('p3')" class="btn-secondary px-3 py-1.5 rounded-lg text-xs flex items-center gap-1.5" title="Language Preferences">
            Prefs
            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
          </button>
          <div id="p3-prefs-dropdown" class="hidden absolute right-0 top-full mt-1 bg-white border border-ink-200 rounded-lg shadow-lg py-1 z-20 min-w-[160px]">
            <button onclick="exportPreferences();togglePrefsDropdown('p3')" class="w-full text-left px-3 py-1.5 text-xs hover:bg-ink-50 flex items-center gap-2">
              <svg class="w-3 h-3 text-ink-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
              Export Preferences
            </button>
            <label class="w-full text-left px-3 py-1.5 text-xs hover:bg-ink-50 flex items-center gap-2 cursor-pointer">
              <svg class="w-3 h-3 text-ink-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m4-8l-4-4m0 0L16 8m4-4v12"/></svg>
              Import Preferences
              <input type="file" accept=".json" onchange="importPreferences(event);togglePrefsDropdown('p3')" class="hidden">
            </label>
          </div>
        </div>
        <button onclick="toggleSettingsPanel()" class="btn-secondary p-1.5 rounded-lg" title="Settings">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.066 2.573c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.573 1.066c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.066-2.573c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><circle cx="12" cy="12" r="3"/></svg>
        </button>
      </div>
    </div>
    <!-- Secondary Toolbar -->
    <div class="px-4 py-1.5 flex items-center justify-between border-t border-ink-100 bg-ink-50">
      <button onclick="goToPhase(2)" class="btn-secondary px-2 py-1 rounded-lg text-xs flex items-center gap-1" title="Back to Workbench">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
        Workbench
      </button>
      <div class="relative" id="export-dropdown-container">
        <button onclick="toggleExportDropdown()" class="btn-accent px-4 py-1.5 rounded-lg text-xs font-medium flex items-center gap-1.5">
          <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/></svg>
          Export
          <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
        </button>
        <div id="export-dropdown" class="hidden absolute right-0 top-full mt-1 bg-white border border-ink-200 rounded-lg shadow-lg py-1 z-20 min-w-[140px]">
          <button onclick="exportEPUB();toggleExportDropdown()" class="w-full text-left px-3 py-1.5 text-xs hover:bg-ink-50 font-medium">EPUB</button>
          <button onclick="exportDOCX();toggleExportDropdown()" class="w-full text-left px-3 py-1.5 text-xs hover:bg-ink-50">DOCX</button>
          <button onclick="exportTXT();toggleExportDropdown()" class="w-full text-left px-3 py-1.5 text-xs hover:bg-ink-50">TXT</button>
        </div>
      </div>
    </div>
  </header>

  <div class="flex-1 flex overflow-hidden">
    <!-- Left: Document Preview -->
    <div id="p3-preview" class="w-[55%] overflow-y-auto p-8 bg-white border-r border-ink-200">
      <div id="p3-document" class="max-w-2xl mx-auto"></div>
    </div>

    <!-- Right: Controls -->
    <div id="p3-controls" class="w-[45%] overflow-y-auto bg-ink-50 p-5 space-y-5">

      <!-- Book Info -->
      <div class="bg-white rounded-xl border border-ink-200 p-4 space-y-3">
        <h3 class="text-xs uppercase tracking-wider text-ink-400 font-semibold">Book Info</h3>
        <div class="flex items-start gap-3">
          <div id="p3-cover-thumb" class="w-20 h-28 bg-ink-100 rounded border border-ink-200 flex items-center justify-center overflow-hidden shrink-0">
            <span class="text-ink-300 text-[10px]">No Cover</span>
          </div>
          <div class="space-y-2 flex-1 min-w-0">
            <div>
              <label class="block text-[10px] text-ink-500 mb-0.5">Title</label>
              <input type="text" id="p3-book-title" class="w-full px-2 py-1.5 rounded-lg border border-ink-200 text-sm focus:outline-none focus:border-accent" placeholder="Book Title">
            </div>
            <div class="grid grid-cols-2 gap-x-3 gap-y-1 text-[10px]">
              <div><span class="text-ink-400">Language:</span> <span id="p3-book-lang" class="text-ink-700 font-medium">-</span></div>
              <div><span class="text-ink-400">Chapters:</span> <span id="p3-book-chapters" class="text-ink-700 font-medium">-</span></div>
              <div><span class="text-ink-400">Segments:</span> <span id="p3-book-segments" class="text-ink-700 font-medium">-</span></div>
              <div><span class="text-ink-400">Progress:</span> <span id="p3-book-progress" class="text-ink-700 font-medium">-</span></div>
              <div id="p3-book-creator-row" class="col-span-2 hidden"><span class="text-ink-400">Author:</span> <span id="p3-book-creator" class="text-ink-700 font-medium">-</span></div>
            </div>
            <label class="btn-secondary px-2 py-1 rounded text-[10px] cursor-pointer inline-block">
              Replace Cover
              <input type="file" accept="image/*" onchange="replaceBookCover(event)" class="hidden">
            </label>
          </div>
        </div>
      </div>

      <!-- Body Typography -->
      <div class="bg-white rounded-xl border border-ink-200 p-4 space-y-4">
        <h3 class="text-xs uppercase tracking-wider text-ink-400 font-semibold">Body Typography</h3>

        <div class="flex gap-3">
          <div class="flex-1">
            <label class="block text-xs text-ink-500 mb-1">Font Family</label>
            <select id="typo-font" class="w-full px-3 py-2 rounded-lg border border-ink-200 text-sm bg-white focus:outline-none focus:border-accent">
              <option value="'Noto Serif', serif">Noto Serif</option>
              <option value="'Noto Sans', sans-serif">Noto Sans</option>
              <option value="'Lora', serif">Lora</option>
              <option value="'Merriweather', serif">Merriweather</option>
              <option value="'IBM Plex Sans', sans-serif">IBM Plex Sans</option>
              <option value="'DM Sans', sans-serif">DM Sans</option>
              <option value="system-ui, sans-serif">System UI</option>
            </select>
          </div>
          <div class="w-28">
            <label class="block text-xs text-ink-500 mb-1">Heading</label>
            <select id="para-heading" class="w-full px-2 py-2 rounded-lg border border-ink-200 text-sm bg-white focus:outline-none focus:border-accent" title="Select a paragraph in preview first">
              <option value="p">Body</option>
              <option value="h1">H1</option>
              <option value="h2">H2</option>
              <option value="h3">H3</option>
              <option value="h4">H4</option>
            </select>
          </div>
        </div>

        <div class="flex items-center gap-2">
          <input type="checkbox" id="para-divider" class="accent-accent">
          <label for="para-divider" class="text-xs text-ink-500">Chapter divider above</label>
          <span id="p3-no-selection" class="text-[10px] text-ink-300 ml-auto">(select a paragraph)</span>
        </div>

        <div class="grid grid-cols-2 gap-3">
          <div>
            <label class="block text-xs text-ink-500 mb-1">Font Size</label>
            <div class="flex items-center border border-ink-200 rounded-lg overflow-hidden">
              <button onclick="stepInput('typo-size',-1)" class="px-2 py-1.5 bg-ink-50 hover:bg-ink-100 text-ink-500 text-sm border-r border-ink-200 leading-none">&minus;</button>
              <input type="number" id="typo-size" min="12" max="32" value="16" step="1" class="flex-1 w-full px-1 py-1.5 text-sm text-center focus:outline-none border-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none">
              <button onclick="stepInput('typo-size',1)" class="px-2 py-1.5 bg-ink-50 hover:bg-ink-100 text-ink-500 text-sm border-l border-ink-200 leading-none">+</button>
              <span class="px-1.5 text-[10px] text-ink-400 bg-ink-50 border-l border-ink-200 py-1.5">px</span>
            </div>
          </div>
          <div>
            <label class="block text-xs text-ink-500 mb-1">Line Height</label>
            <div class="flex items-center border border-ink-200 rounded-lg overflow-hidden">
              <button onclick="stepInput('typo-lh',-1)" class="px-2 py-1.5 bg-ink-50 hover:bg-ink-100 text-ink-500 text-sm border-r border-ink-200 leading-none">&minus;</button>
              <input type="number" id="typo-lh" min="1.2" max="2.5" value="1.8" step="0.1" class="flex-1 w-full px-1 py-1.5 text-sm text-center focus:outline-none border-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none">
              <button onclick="stepInput('typo-lh',1)" class="px-2 py-1.5 bg-ink-50 hover:bg-ink-100 text-ink-500 text-sm border-l border-ink-200 leading-none">+</button>
            </div>
          </div>
        </div>

        <div class="grid grid-cols-2 gap-3">
          <div>
            <label class="block text-xs text-ink-500 mb-1">Letter Spacing</label>
            <div class="flex items-center border border-ink-200 rounded-lg overflow-hidden">
              <button onclick="stepInput('typo-ls',-1)" class="px-2 py-1.5 bg-ink-50 hover:bg-ink-100 text-ink-500 text-sm border-r border-ink-200 leading-none">&minus;</button>
              <input type="number" id="typo-ls" min="-0.05" max="0.15" value="0" step="0.005" class="flex-1 w-full px-1 py-1.5 text-sm text-center focus:outline-none border-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none">
              <button onclick="stepInput('typo-ls',1)" class="px-2 py-1.5 bg-ink-50 hover:bg-ink-100 text-ink-500 text-sm border-l border-ink-200 leading-none">+</button>
              <span class="px-1.5 text-[10px] text-ink-400 bg-ink-50 border-l border-ink-200 py-1.5">em</span>
            </div>
          </div>
          <div>
            <label class="block text-xs text-ink-500 mb-1">Paragraph Spacing</label>
            <div class="flex items-center border border-ink-200 rounded-lg overflow-hidden">
              <button onclick="stepInput('typo-ps',-1)" class="px-2 py-1.5 bg-ink-50 hover:bg-ink-100 text-ink-500 text-sm border-r border-ink-200 leading-none">&minus;</button>
              <input type="number" id="typo-ps" min="0" max="3" value="1" step="0.1" class="flex-1 w-full px-1 py-1.5 text-sm text-center focus:outline-none border-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none">
              <button onclick="stepInput('typo-ps',1)" class="px-2 py-1.5 bg-ink-50 hover:bg-ink-100 text-ink-500 text-sm border-l border-ink-200 leading-none">+</button>
              <span class="px-1.5 text-[10px] text-ink-400 bg-ink-50 border-l border-ink-200 py-1.5">em</span>
            </div>
          </div>
        </div>

        <div>
          <label class="block text-xs text-ink-500 mb-1">Page Margin</label>
          <div class="flex items-center border border-ink-200 rounded-lg overflow-hidden w-1/2">
            <button onclick="stepInput('typo-margin',-1)" class="px-2 py-1.5 bg-ink-50 hover:bg-ink-100 text-ink-500 text-sm border-r border-ink-200 leading-none">&minus;</button>
            <input type="number" id="typo-margin" min="1" max="6" value="2" step="0.5" class="flex-1 w-full px-1 py-1.5 text-sm text-center focus:outline-none border-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none">
            <button onclick="stepInput('typo-margin',1)" class="px-2 py-1.5 bg-ink-50 hover:bg-ink-100 text-ink-500 text-sm border-l border-ink-200 leading-none">+</button>
            <span class="px-1.5 text-[10px] text-ink-400 bg-ink-50 border-l border-ink-200 py-1.5">rem</span>
          </div>
        </div>

        <div>
          <label class="block text-xs text-ink-500 mb-1">Text Alignment</label>
          <div class="flex gap-1">
            <button class="typo-align flex-1 py-1.5 rounded-lg text-xs border border-ink-200 bg-white hover:bg-ink-50" data-align="left">Left</button>
            <button class="typo-align flex-1 py-1.5 rounded-lg text-xs border border-ink-200 bg-white hover:bg-ink-50" data-align="center">Center</button>
            <button class="typo-align flex-1 py-1.5 rounded-lg text-xs border border-ink-200 bg-white hover:bg-ink-50" data-align="right">Right</button>
            <button class="typo-align flex-1 py-1.5 rounded-lg text-xs border border-ink-200 bg-white hover:bg-ink-50" data-align="justify">Justify</button>
          </div>
        </div>
      </div>

      <!-- Custom Style Templates -->
      <div class="bg-white rounded-xl border border-ink-200 p-4 space-y-3">
        <h3 class="text-xs uppercase tracking-wider text-ink-400 font-semibold">Custom Style Templates</h3>
        <div>
          <label class="block text-xs text-ink-500 mb-1">Editing Level</label>
          <select id="hs-level" class="w-full px-3 py-2 rounded-lg border border-ink-200 text-sm bg-white focus:outline-none focus:border-accent">
            <option value="h1">Heading 1 (H1)</option>
            <option value="h2">Heading 2 (H2)</option>
            <option value="h3">Heading 3 (H3)</option>
            <option value="h4">Heading 4 (H4)</option>
          </select>
        </div>
        <div class="grid grid-cols-2 gap-3">
          <div>
            <label class="block text-xs text-ink-500 mb-1">Font Size</label>
            <select id="hs-font-size" class="w-full px-3 py-2 rounded-lg border border-ink-200 text-sm bg-white focus:outline-none focus:border-accent">
              <option value="1em">1em</option>
              <option value="1.1em">1.1em</option>
              <option value="1.25em">1.25em</option>
              <option value="1.5em">1.5em</option>
              <option value="1.75em">1.75em</option>
              <option value="2em">2em</option>
              <option value="2.5em">2.5em</option>
              <option value="3em">3em</option>
            </select>
          </div>
          <div>
            <label class="block text-xs text-ink-500 mb-1">Font Weight</label>
            <select id="hs-font-weight" class="w-full px-3 py-2 rounded-lg border border-ink-200 text-sm bg-white focus:outline-none focus:border-accent">
              <option value="400">Regular (400)</option>
              <option value="500">Medium (500)</option>
              <option value="600">Semibold (600)</option>
              <option value="700">Bold (700)</option>
              <option value="800">Extra Bold (800)</option>
            </select>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-3">
          <div>
            <label class="block text-xs text-ink-500 mb-1">Color</label>
            <input type="color" id="hs-color" value="#292524" class="w-full h-8 rounded-lg border border-ink-200 cursor-pointer">
          </div>
          <div>
            <label class="block text-xs text-ink-500 mb-1">Alignment</label>
            <select id="hs-align" class="w-full px-3 py-2 rounded-lg border border-ink-200 text-sm bg-white focus:outline-none focus:border-accent">
              <option value="">Inherit</option>
              <option value="left">Left</option>
              <option value="center">Center</option>
              <option value="right">Right</option>
            </select>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-3">
          <div>
            <label class="block text-xs text-ink-500 mb-1">Margin Top</label>
            <select id="hs-margin-top" class="w-full px-3 py-2 rounded-lg border border-ink-200 text-sm bg-white focus:outline-none focus:border-accent">
              <option value="0">0</option><option value="0.3em">0.3em</option><option value="0.5em">0.5em</option><option value="0.6em">0.6em</option><option value="0.8em">0.8em</option><option value="1em">1em</option><option value="1.5em">1.5em</option><option value="2em">2em</option>
            </select>
          </div>
          <div>
            <label class="block text-xs text-ink-500 mb-1">Margin Bottom</label>
            <select id="hs-margin-bottom" class="w-full px-3 py-2 rounded-lg border border-ink-200 text-sm bg-white focus:outline-none focus:border-accent">
              <option value="0">0</option><option value="0.2em">0.2em</option><option value="0.3em">0.3em</option><option value="0.4em">0.4em</option><option value="0.5em">0.5em</option><option value="0.8em">0.8em</option><option value="1em">1em</option><option value="1.5em">1.5em</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Custom CSS -->
      <div class="bg-white rounded-xl border border-ink-200 p-4 space-y-3">
        <h3 class="text-xs uppercase tracking-wider text-ink-400 font-semibold">Custom CSS</h3>
        <textarea id="custom-css" class="w-full h-24 px-3 py-2 rounded-lg border border-ink-200 text-xs font-mono focus:outline-none focus:border-accent resize-none" placeholder="/* Custom styles applied to preview */"></textarea>
      </div>
    </div>
  </div>
</div>

<!-- Popup AI Editor (Phase 3) -->
<div id="popup-editor" class="hidden fixed z-50 popup-editor bg-white rounded-xl border border-ink-200 w-[380px] p-4 space-y-3">
  <div class="flex items-center justify-between">
    <span class="text-[10px] uppercase tracking-wider text-ink-400 font-semibold">AI Editor</span>
    <button onclick="closePopupEditor()" class="text-ink-400 hover:text-ink-600"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg></button>
  </div>
  <div id="popup-selected-text" class="text-xs text-ink-600 bg-ink-50 border border-ink-100 rounded-lg p-3 max-h-24 overflow-y-auto italic"></div>
  <div class="flex gap-2">
    <input type="text" id="popup-chat-input" class="flex-1 px-3 py-2 rounded-lg border border-ink-200 text-sm focus:outline-none focus:border-accent" placeholder="Rewrite, optimize, unify style...">
    <button id="popup-send-btn" class="btn-accent px-3 py-2 rounded-lg text-xs">Send</button>
  </div>
  <div id="popup-loading" class="hidden text-center py-2">
    <div class="w-5 h-5 border-2 border-ink-200 border-t-accent rounded-full spinner inline-block"></div>
  </div>
  <div id="popup-suggestion" class="hidden">
    <div id="popup-suggestion-text" class="text-sm text-ink-700 bg-green-50 border border-green-200 rounded-lg p-3 mb-2"></div>
    <div class="flex gap-2">
      <button id="popup-accept" class="btn-green flex-1 py-2 rounded-lg text-xs">Accept</button>
      <button id="popup-reject" class="btn-red flex-1 py-2 rounded-lg text-xs">Reject</button>
      <button id="popup-refine" class="btn-accent flex-1 py-2 rounded-lg text-xs">Refine</button>
    </div>
  </div>
</div>

<!-- Floating Glossary Add Button -->
<div id="glossary-float-btn" class="hidden fixed z-[60] glossary-float-btn bg-white border border-ink-200 rounded-lg shadow-lg px-3 py-1.5 cursor-pointer hover:bg-accent hover:text-white transition-colors text-xs font-medium flex items-center gap-1.5" onclick="addGlossaryFromSelection()">
  <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/></svg>
  Add to Glossary
</div>

<!-- Glossary Retroactive Apply Modal -->
<div id="glossary-retro-modal" class="hidden fixed inset-0 z-[90] modal-backdrop flex items-center justify-center p-4" onclick="if(event.target===this)closeGlossaryRetroModal()">
  <div class="modal-content bg-white rounded-2xl border border-ink-200 shadow-xl max-w-md w-full p-6 space-y-4">
    <h3 class="font-serif text-xl text-ink-900 italic">Apply to Existing Translations?</h3>
    <p id="glossary-retro-desc" class="text-sm text-ink-600"></p>
    <div id="glossary-retro-preview" class="max-h-48 overflow-y-auto space-y-2"></div>
    <div class="flex gap-2 pt-2">
      <button id="glossary-retro-apply" class="btn-accent flex-1 py-2.5 rounded-xl text-sm font-medium">Apply All</button>
      <button onclick="closeGlossaryRetroModal()" class="btn-secondary flex-1 py-2.5 rounded-xl text-sm">Skip</button>
    </div>
  </div>
</div>

<!-- Match Summary Modal -->
<div id="match-modal" class="hidden fixed inset-0 z-[90] modal-backdrop flex items-center justify-center p-4">
  <div class="modal-content bg-white rounded-2xl border border-ink-200 shadow-xl max-w-md w-full p-6 space-y-4">
    <h3 class="font-serif text-xl text-ink-900 italic">Progress Restored</h3>
    <div id="match-modal-body" class="space-y-3"></div>
    <div class="flex gap-2 pt-2">
      <button id="match-modal-proceed" class="btn-accent flex-1 py-2.5 rounded-xl text-sm font-medium">Proceed</button>
      <button id="match-modal-cancel" class="btn-secondary flex-1 py-2.5 rounded-xl text-sm">Cancel</button>
    </div>
  </div>
</div>


<script>
// ============================================================
// SECTION: CONSTANTS & CONFIGURATION
// ============================================================
const DB_NAME = 'TransLoomDB';
const DB_VERSION = 1;
const STORE_PROJECTS = 'projects';
const STORE_PREFS = 'preferences';

const LANGUAGES = [
  { code: 'auto', label: 'Auto-detect', native: 'Auto-detect' },
  { code: 'en', label: 'English', native: 'English' },
  { code: 'zh', label: 'Chinese', native: '简体中文' },
  { code: 'ja', label: 'Japanese', native: '日本語' },
  { code: 'ko', label: 'Korean', native: '한국어' },
  { code: 'es', label: 'Spanish', native: 'Español' },
  { code: 'fr', label: 'French', native: 'Français' },
  { code: 'de', label: 'German', native: 'Deutsch' },
  { code: 'pt', label: 'Portuguese', native: 'Português' },
  { code: 'ru', label: 'Russian', native: 'Русский' },
  { code: 'ar', label: 'Arabic', native: 'العربية' },
  { code: 'hi', label: 'Hindi', native: 'हिन्दी' },
  { code: 'it', label: 'Italian', native: 'Italiano' },
  { code: 'nl', label: 'Dutch', native: 'Nederlands' },
  { code: 'pl', label: 'Polish', native: 'Polski' },
  { code: 'tr', label: 'Turkish', native: 'Türkçe' },
  { code: 'th', label: 'Thai', native: 'ไทย' },
  { code: 'vi', label: 'Vietnamese', native: 'Tiếng Việt' },
  { code: 'id', label: 'Indonesian', native: 'Bahasa Indonesia' },
];

const AI_MODELS = [
  // Premium tier
  { id: 'claude-sonnet-4', label: 'Claude Sonnet 4', tier: 'premium' },
  { id: 'gpt-4o', label: 'GPT-4o', tier: 'premium' },
  { id: 'meta-llama/llama-4-maverick', label: 'Llama 4 Maverick', tier: 'premium' },
  // Free tier
  { id: 'google/gemini-2.5-flash', label: 'Gemini 2.5 Flash', tier: 'free' },
  { id: 'google/gemini-2.5-pro', label: 'Gemini 2.5 Pro', tier: 'free' },
  { id: 'deepseek/deepseek-chat', label: 'DeepSeek V3', tier: 'free' },
];

const PREF_ANALYSIS_INTERVAL = 3;

// ============================================================
// SECTION: STATE MANAGEMENT
// ============================================================
const AppState = {
  currentPhase: 1,
  projectId: null,
  project: null,
  currentSegmentIndex: 0,
  selectedOptionIndex: -1,
  isGenerating: false,
  popupContext: null,
  selectedParaIndex: -1,
  confirmedCount: 0,
  activeSidebarTab: 'segments',
  collapsedChapters: {},
  typography: {
    fontFamily: "'Noto Serif', serif",
    fontSize: 16,
    lineHeight: 1.8,
    letterSpacing: 0,
    textAlign: 'justify',
    paragraphSpacing: 1,
    pageMargin: 2,
  },
  paraSettings: {},
  headingStyles: {
    h1: { fontSize: '2em', fontWeight: '700', color: '', marginTop: '1em', marginBottom: '0.5em', textAlign: '' },
    h2: { fontSize: '1.5em', fontWeight: '600', color: '', marginTop: '0.8em', marginBottom: '0.4em', textAlign: '' },
    h3: { fontSize: '1.25em', fontWeight: '600', color: '', marginTop: '0.6em', marginBottom: '0.3em', textAlign: '' },
    h4: { fontSize: '1.1em', fontWeight: '600', color: '', marginTop: '0.5em', marginBottom: '0.2em', textAlign: '' },
  },
  uploadedFile: null,
  uploadedText: null,
  uploadedProgressFile: null,
  isPremium: false,
  codeUnlock: false,
  aiProvider: 'puter',
  apiKey: '',
};

// ============================================================
// SECTION: IndexedDB DATABASE LAYER
// ============================================================
let db = null;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains(STORE_PROJECTS)) {
        d.createObjectStore(STORE_PROJECTS, { keyPath: 'id' });
      }
      if (!d.objectStoreNames.contains(STORE_PREFS)) {
        const ps = d.createObjectStore(STORE_PREFS, { keyPath: 'id', autoIncrement: true });
        ps.createIndex('projectId', 'projectId', { unique: false });
      }
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = (e) => reject(e.target.error);
  });
}

function dbPut(store, data) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    const s = tx.objectStore(store);
    const r = s.put(data);
    r.onsuccess = () => resolve(r.result);
    r.onerror = () => reject(r.error);
  });
}

function dbGet(store, key) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readonly');
    const s = tx.objectStore(store);
    const r = s.get(key);
    r.onsuccess = () => resolve(r.result);
    r.onerror = () => reject(r.error);
  });
}

function dbGetAll(store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readonly');
    const s = tx.objectStore(store);
    const r = s.getAll();
    r.onsuccess = () => resolve(r.result);
    r.onerror = () => reject(r.error);
  });
}

function dbGetByIndex(store, indexName, key) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readonly');
    const s = tx.objectStore(store);
    const idx = s.index(indexName);
    const r = idx.getAll(key);
    r.onsuccess = () => resolve(r.result);
    r.onerror = () => reject(r.error);
  });
}

function dbDelete(store, key) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    const s = tx.objectStore(store);
    const r = s.delete(key);
    r.onsuccess = () => resolve();
    r.onerror = () => reject(r.error);
  });
}

async function saveProject() {
  if (AppState.project) {
    await dbPut(STORE_PROJECTS, AppState.project);
    localStorage.setItem('transloom_lastProject', AppState.project.id);
  }
}

// ============================================================
// SECTION: DRAFT AUTO-SAVE
// ============================================================
function saveDraft() {
  if (!AppState.project) return;
  const draft = {
    currentSegmentIndex: AppState.currentSegmentIndex,
    selectedOptionIndex: AppState.selectedOptionIndex,
    customText: document.getElementById('p2-custom-input')?.value || '',
    editedOptionText: document.getElementById('editable-option')?.textContent || '',
    writeOwnVisible: !document.getElementById('p2-write-own')?.classList.contains('hidden'),
    timestamp: Date.now(),
  };
  localStorage.setItem('transloom_draft_' + AppState.project.id, JSON.stringify(draft));
}

function restoreDraft() {
  if (!AppState.project) return;
  const raw = localStorage.getItem('transloom_draft_' + AppState.project.id);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch { return null; }
}

function clearDraft() {
  if (!AppState.project) return;
  localStorage.removeItem('transloom_draft_' + AppState.project.id);
}

let _draftSaveTimer = null;
function scheduleDraftSave() {
  if (_draftSaveTimer) clearTimeout(_draftSaveTimer);
  _draftSaveTimer = setTimeout(saveDraft, 500);
}

// ============================================================
// SECTION: FILE PARSING (TXT, DOCX, EPUB)
// ============================================================
async function parseFile(file) {
  const ext = file.name.split('.').pop().toLowerCase();
  if (ext === 'txt') return await parseTXT(file);
  if (ext === 'docx') return await parseDOCX(file);
  if (ext === 'epub') return await parseEPUB(file);
  throw new Error('Unsupported file format: ' + ext + '. Use TXT, DOCX, or EPUB.');
}

function parseTXT(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const text = e.target.result;
      resolve(segmentText(text));
    };
    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsText(file);
  });
}

async function parseDOCX(file) {
  const arrayBuffer = await file.arrayBuffer();
  const result = await mammoth.extractRawText({ arrayBuffer });
  return segmentText(result.value);
}

async function parseEPUB(file) {
  const arrayBuffer = await file.arrayBuffer();
  const zip = await JSZip.loadAsync(arrayBuffer);

  const containerXml = await zip.file('META-INF/container.xml')?.async('string');
  let opfPath = 'content.opf';
  if (containerXml) {
    const match = containerXml.match(/full-path="([^"]+)"/);
    if (match) opfPath = match[1];
  }

  // Try multiple possible OPF locations
  let opfContent = await zip.file(opfPath)?.async('string');
  if (!opfContent) {
    for (const [path, zipEntry] of Object.entries(zip.files)) {
      if (path.endsWith('.opf') && !zipEntry.dir) {
        opfContent = await zipEntry.async('string');
        opfPath = path;
        break;
      }
    }
  }

  // Helper: find a zip entry by path, trying normalized variants
  function findZipEntry(targetPath) {
    let entry = zip.file(targetPath);
    if (entry) return entry;
    entry = zip.file(targetPath.replace(/^\//, ''));
    if (entry) return entry;
    const lower = targetPath.toLowerCase();
    for (const [p, e] of Object.entries(zip.files)) {
      if (p.toLowerCase() === lower || p.toLowerCase() === lower.replace(/^\//, '')) return e;
    }
    return null;
  }

  // === PHASE A: Extract EPUB's own TOC (NCX for EPUB2, nav for EPUB3) ===
  let epubTocEntries = []; // Array of {title, href}
  const opfDir = opfContent ? (opfPath.includes('/') ? opfPath.substring(0, opfPath.lastIndexOf('/') + 1) : '') : '';

  if (opfContent) {
    // Try EPUB3 nav document first
    const navItemMatch = opfContent.match(/<item\s[^>]*properties\s*=\s*"[^"]*nav[^"]*"[^>]*>/i);
    if (navItemMatch) {
      const hrefMatch = navItemMatch[0].match(/href\s*=\s*"([^"]+)"/i);
      if (hrefMatch) {
        const navPath = opfDir + decodeURIComponent(hrefMatch[1]);
        const navEntry = findZipEntry(navPath);
        if (navEntry) {
          const navHtml = await navEntry.async('string');
          epubTocEntries = parseNavToc(navHtml);
        }
      }
    }

    // If no EPUB3 nav, try EPUB2 NCX
    if (epubTocEntries.length === 0) {
      const ncxItemMatch = opfContent.match(/<item\s[^>]*media-type\s*=\s*"application\/x-dtbncx\+xml"[^>]*>/i);
      if (ncxItemMatch) {
        const hrefMatch = ncxItemMatch[0].match(/href\s*=\s*"([^"]+)"/i);
        if (hrefMatch) {
          const ncxPath = opfDir + decodeURIComponent(hrefMatch[1]);
          const ncxEntry = findZipEntry(ncxPath);
          if (ncxEntry) {
            const ncxXml = await ncxEntry.async('string');
            epubTocEntries = parseNcxToc(ncxXml);
          }
        }
      }
    }
  }

  // === PHASE A2: Extract cover image ===
  let coverImageData = null; // {dataUrl, mediaType}
  if (opfContent) {
    // Method 1: EPUB3 cover-image property
    let coverHref = null;
    let coverMediaType = null;
    const coverPropMatch = opfContent.match(/<item\s[^>]*properties\s*=\s*"[^"]*cover-image[^"]*"[^>]*>/i);
    if (coverPropMatch) {
      const h = coverPropMatch[0].match(/href\s*=\s*"([^"]+)"/i);
      const mt = coverPropMatch[0].match(/media-type\s*=\s*"([^"]+)"/i);
      if (h) { coverHref = decodeURIComponent(h[1]); coverMediaType = mt ? mt[1] : 'image/jpeg'; }
    }
    // Method 2: EPUB2 <meta name="cover" content="cover-id"/>
    if (!coverHref) {
      const metaCoverMatch = opfContent.match(/<meta\s[^>]*name\s*=\s*"cover"[^>]*content\s*=\s*"([^"]+)"/i)
        || opfContent.match(/<meta\s[^>]*content\s*=\s*"([^"]+)"[^>]*name\s*=\s*"cover"/i);
      if (metaCoverMatch) {
        const coverId = metaCoverMatch[1];
        const coverItemRx = new RegExp(`<item\\s[^>]*id\\s*=\\s*"${coverId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}"[^>]*>`, 'i');
        const coverItemMatch = opfContent.match(coverItemRx);
        if (coverItemMatch) {
          const h = coverItemMatch[0].match(/href\s*=\s*"([^"]+)"/i);
          const mt = coverItemMatch[0].match(/media-type\s*=\s*"([^"]+)"/i);
          if (h) { coverHref = decodeURIComponent(h[1]); coverMediaType = mt ? mt[1] : 'image/jpeg'; }
        }
      }
    }
    // Method 3: look for common cover filenames
    if (!coverHref) {
      for (const [p] of Object.entries(zip.files)) {
        if (/cover\.(jpe?g|png|gif|webp|svg)$/i.test(p)) {
          coverHref = p;
          const extMatch = p.match(/\.(jpe?g|png|gif|webp|svg)$/i);
          coverMediaType = extMatch ? 'image/' + (extMatch[1] === 'jpg' ? 'jpeg' : extMatch[1].toLowerCase()) : 'image/jpeg';
          break;
        }
      }
    }
    if (coverHref) {
      const coverPath = coverHref.startsWith(opfDir) ? coverHref : opfDir + coverHref;
      const coverEntry = findZipEntry(coverPath) || findZipEntry(coverHref);
      if (coverEntry && !coverEntry.dir) {
        try {
          const coverBase64 = await coverEntry.async('base64');
          coverImageData = { dataUrl: `data:${coverMediaType};base64,${coverBase64}`, mediaType: coverMediaType };
        } catch (e) { console.warn('Cover extraction failed:', e); }
      }
    }
  }

  // === PHASE A3: Extract EPUB metadata from OPF ===
  let epubMetadata = {};
  if (opfContent) {
    const titleM = opfContent.match(/<dc:title[^>]*>([\s\S]*?)<\/dc:title>/i);
    const creatorM = opfContent.match(/<dc:creator[^>]*>([\s\S]*?)<\/dc:creator>/i);
    const langM = opfContent.match(/<dc:language[^>]*>([\s\S]*?)<\/dc:language>/i);
    const descM = opfContent.match(/<dc:description[^>]*>([\s\S]*?)<\/dc:description>/i);
    const pubM = opfContent.match(/<dc:publisher[^>]*>([\s\S]*?)<\/dc:publisher>/i);
    epubMetadata = {
      title: titleM ? titleM[1].trim() : '',
      creator: creatorM ? creatorM[1].trim() : '',
      language: langM ? langM[1].trim() : '',
      description: descM ? descM[1].trim() : '',
      publisher: pubM ? pubM[1].trim() : '',
    };
  }

  // === PHASE B: Parse spine to get reading order ===
  let orderedPaths = [];
  const itemMap = {};

  if (opfContent) {
    const itemTagMatches = [...opfContent.matchAll(/<item\s([^>]*?)\/?>/gi)];
    for (const m of itemTagMatches) {
      const attrs = m[1];
      const idMatch = attrs.match(/id\s*=\s*"([^"]+)"/i);
      const hrefMatch = attrs.match(/href\s*=\s*"([^"]+)"/i);
      const typeMatch = attrs.match(/media-type\s*=\s*"([^"]+)"/i);
      if (!idMatch || !hrefMatch || !typeMatch) continue;
      const mediaType = typeMatch[1].toLowerCase();
      if (mediaType === 'application/xhtml+xml' || mediaType === 'text/html') {
        const href = decodeURIComponent(hrefMatch[1]);
        itemMap[idMatch[1]] = opfDir + href;
      }
    }

    const spineMatches = [...opfContent.matchAll(/<itemref\s[^>]*idref\s*=\s*"([^"]+)"[^>]*\/?>/gi)];
    orderedPaths = spineMatches.map(m => itemMap[m[1]]).filter(Boolean);

    if (orderedPaths.length === 0) {
      for (const id in itemMap) orderedPaths.push(itemMap[id]);
    }
  }

  if (orderedPaths.length === 0) {
    // Fallback: scan all HTML files
    orderedPaths = Object.keys(zip.files)
      .filter(p => p.match(/\.(x?html?|htm)$/i) && !p.includes('META-INF') && !p.endsWith('.opf') && !p.endsWith('.ncx'))
      .sort();
  }

  // === PHASE C: Extract structured blocks from each spine file ===
  // Build a map from filename to TOC entries for cross-referencing
  const tocByFile = {};
  for (const toc of epubTocEntries) {
    if (toc.href) {
      // TOC hrefs may be like "chapter1.xhtml#sec1" or just "chapter1.xhtml"
      const baseHref = toc.href.split('#')[0];
      if (!tocByFile[baseHref]) tocByFile[baseHref] = [];
      tocByFile[baseHref].push(toc);
    }
  }

  // structuredBlocks: Array of {text, tag, hasLink, linkHref, isHeading, spineFile, spineIndex, tocMatch}
  const structuredBlocks = [];
  let spineIndex = 0;

  for (const path of orderedPaths) {
    const entry = findZipEntry(path);
    if (!entry || entry.dir) { spineIndex++; continue; }
    const html = await entry.async('string');
    const blocks = extractStructuredBlocks(html, path, spineIndex, tocByFile);
    structuredBlocks.push(...blocks);
    spineIndex++;
  }

  // If still no text, last-resort scan
  if (structuredBlocks.length === 0) {
    const htmlPaths = Object.keys(zip.files)
      .filter(p => p.match(/\.(x?html?|htm)$/i) && !p.includes('META-INF'))
      .sort();
    for (const path of htmlPaths) {
      const entry = zip.files[path];
      if (entry && !entry.dir) {
        const html = await entry.async('string');
        structuredBlocks.push(...extractStructuredBlocks(html, path, spineIndex++, tocByFile));
      }
    }
  }

  if (structuredBlocks.length === 0) {
    return [{ id: 0, source: '', status: 'pending', translations: [], selectedIndex: -1, userFinal: '', previousOptions: [], chapterId: 0, chapterTitle: 'All Segments' }];
  }

  // === PHASE D: Build segments from structured blocks ===
  // Merge very short blocks, but preserve structural signals
  const segments = buildSegmentsFromBlocks(structuredBlocks);

  // Store EPUB TOC and structural metadata on segments for AI analysis
  segments._epubToc = epubTocEntries;
  segments._structuredBlocks = structuredBlocks;
  segments._coverImage = coverImageData;
  segments._epubMetadata = epubMetadata;

  return segments;
}

// Parse EPUB3 navigation document <nav epub:type="toc">
function parseNavToc(navHtml) {
  const entries = [];
  const cleaned = navHtml.replace(/<\?xml[^?]*\?>/gi, '').replace(/<!DOCTYPE[^>]*>/gi, '');
  const div = document.createElement('div');
  div.innerHTML = cleaned;
  // Find the toc nav
  let navEl = div.querySelector('nav[epub\\:type="toc"]') || div.querySelector('nav[*|type="toc"]');
  if (!navEl) {
    // Fallback: look for any nav with "toc" in attributes
    const navs = div.querySelectorAll('nav');
    for (const n of navs) {
      const epubType = n.getAttribute('epub:type') || n.getAttribute('type') || '';
      if (epubType.includes('toc')) { navEl = n; break; }
    }
  }
  if (!navEl) {
    // Last fallback: try finding ol/ul with links inside any nav
    navEl = div.querySelector('nav') || div;
  }
  const links = navEl.querySelectorAll('a[href]');
  for (const a of links) {
    const title = a.textContent.trim();
    const href = a.getAttribute('href') || '';
    if (title) entries.push({ title, href });
  }
  return entries;
}

// Parse EPUB2 NCX table of contents
function parseNcxToc(ncxXml) {
  const entries = [];
  // Extract navPoint entries: <navPoint> ... <navLabel><text>Title</text></navLabel> <content src="file.xhtml"/> ... </navPoint>
  const navPointMatches = [...ncxXml.matchAll(/<navPoint[^>]*>([\s\S]*?)<\/navPoint>/gi)];
  for (const m of navPointMatches) {
    const inner = m[1];
    const textMatch = inner.match(/<navLabel[^>]*>\s*<text[^>]*>([\s\S]*?)<\/text>/i);
    const srcMatch = inner.match(/<content[^>]*src\s*=\s*"([^"]+)"/i);
    if (textMatch) {
      entries.push({
        title: textMatch[1].trim(),
        href: srcMatch ? decodeURIComponent(srcMatch[1]) : '',
      });
    }
  }
  return entries;
}

// Extract structured blocks from an HTML/XHTML file, preserving metadata
function extractStructuredBlocks(html, filePath, spineIdx, tocByFile) {
  const cleaned = html.replace(/<\?xml[^?]*\?>/gi, '').replace(/<!DOCTYPE[^>]*>/gi, '');
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = cleaned;

  // Remove non-content elements
  const removeEls = tempDiv.querySelectorAll('script,style,link,meta,head,nav[epub\\:type="toc"],nav[*|type="toc"]');
  removeEls.forEach(s => s.remove());

  let root = tempDiv.querySelector('body') || tempDiv;

  // Collect leaf block elements
  const allBlocks = root.querySelectorAll('p,h1,h2,h3,h4,h5,h6,div,li,blockquote,td,th,dt,dd,figcaption,pre,article,section');
  const results = [];
  const seen = new Set();

  // Determine which TOC entries map to this file
  const baseName = filePath.split('/').pop().split('#')[0];
  const tocForFile = tocByFile[baseName] || tocByFile[filePath] || tocByFile[filePath.split('/').pop()] || [];
  // Also match by relative path
  for (const key of Object.keys(tocByFile)) {
    if (filePath.endsWith(key) || key.endsWith(baseName)) {
      tocForFile.push(...(tocByFile[key] || []));
    }
  }
  // Deduplicate tocForFile
  const tocTitlesForFile = [...new Set(tocForFile.map(t => t.title))];

  for (const b of allBlocks) {
    const text = b.textContent.trim();
    if (text.length === 0) continue;
    if (seen.has(text)) continue;

    // Only add leaf blocks (no child block elements)
    const childBlocks = b.querySelectorAll('p,h1,h2,h3,h4,h5,h6,div,li,blockquote');
    if (childBlocks.length > 0) continue;
    seen.add(text);

    const tag = b.tagName.toLowerCase();
    const isHeading = /^h[1-6]$/.test(tag);

    // Check if this block or any parent has a heading-like class/style
    let hasHeadingStyle = isHeading;
    if (!hasHeadingStyle) {
      let el = b;
      while (el && el !== root) {
        const cls = (el.className || '').toString().toLowerCase();
        const role = (el.getAttribute('role') || '').toLowerCase();
        if (cls.match(/head(er|ing)|title|chapter|section-title|h[1-6]/i) || role === 'heading') {
          hasHeadingStyle = true;
          break;
        }
        el = el.parentElement;
      }
    }

    // Check if this block contains hyperlinks (common in TOC sections)
    const links = b.querySelectorAll('a[href]');
    const hasLink = links.length > 0;
    let linkHrefs = [];
    if (hasLink) {
      linkHrefs = [...links].map(a => a.getAttribute('href') || '');
    }

    // Check if this text matches any TOC entry for this file
    let tocMatch = null;
    for (const title of tocTitlesForFile) {
      if (title && (text === title || text.startsWith(title) || title.startsWith(text))) {
        tocMatch = title;
        break;
      }
    }

    // Also check if this text matches any global TOC entry
    if (!tocMatch) {
      for (const entry of (tocByFile._allEntries || [])) {
        if (entry.title && (text === entry.title || text.startsWith(entry.title))) {
          tocMatch = entry.title;
          break;
        }
      }
    }

    results.push({
      text,
      innerHTML: b.innerHTML.trim(),
      tag,
      isHeading,
      hasHeadingStyle,
      hasLink,
      linkHrefs,
      spineFile: filePath,
      spineIndex: spineIdx,
      tocMatch,
    });
  }

  // If no block elements found, fall back to full text extraction
  if (results.length === 0) {
    const fallbackText = root.textContent?.trim();
    if (fallbackText) {
      results.push({
        text: fallbackText,
        innerHTML: root.innerHTML?.trim() || fallbackText,
        tag: 'div',
        isHeading: false,
        hasHeadingStyle: false,
        hasLink: false,
        linkHrefs: [],
        spineFile: filePath,
        spineIndex: spineIdx,
        tocMatch: null,
      });
    }
  }

  return results;
}

// Build segments from structured blocks, merging short ones but preserving signal metadata
function buildSegmentsFromBlocks(blocks) {
  const merged = [];
  let current = null;

  for (const block of blocks) {
    // Headings always start a new segment
    if (block.isHeading || block.hasHeadingStyle || block.tocMatch) {
      if (current) merged.push(current);
      current = {
        text: block.text,
        innerHTML: block.innerHTML || block.text,
        _signals: [block],
      };
      continue;
    }

    // If current segment is small and this block is small, merge
    if (current && !current._signals.some(s => s.isHeading || s.hasHeadingStyle || s.tocMatch) &&
        current.text.length + block.text.length < 80 && block.text.length < 40) {
      current.text = current.text + '\n' + block.text;
      current.innerHTML = current.innerHTML + '<br/>' + (block.innerHTML || block.text);
      current._signals.push(block);
    } else {
      if (current) merged.push(current);
      current = {
        text: block.text,
        innerHTML: block.innerHTML || block.text,
        _signals: [block],
      };
    }
  }
  if (current) merged.push(current);

  return merged.map((m, i) => {
    // Determine the dominant structural signal for this segment
    const hasHeading = m._signals.some(s => s.isHeading);
    const hasHeadingStyle = m._signals.some(s => s.hasHeadingStyle);
    const hasLink = m._signals.some(s => s.hasLink);
    const tocMatch = m._signals.find(s => s.tocMatch)?.tocMatch || null;
    const headingTag = m._signals.find(s => s.isHeading)?.tag || null;
    const spineFile = m._signals[0]?.spineFile || '';
    const spineIndex = m._signals[0]?.spineIndex ?? -1;

    return {
      id: i,
      source: m.text,
      sourceHtml: m.innerHTML,
      status: 'pending',
      translations: [],
      selectedIndex: -1,
      userFinal: '',
      previousOptions: [],
      chapterId: 0,
      chapterTitle: 'All Segments',
      _meta: {
        hasHeading,
        hasHeadingStyle,
        hasLink,
        tocMatch,
        headingTag,
        spineFile,
        spineIndex,
      },
    };
  });
}

// Legacy text extraction for non-EPUB formats
function extractTextFromHTML(html) {
  let cleaned = html.replace(/<\?xml[^?]*\?>/gi, '').replace(/<!DOCTYPE[^>]*>/gi, '');
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = cleaned;

  const removeEls = tempDiv.querySelectorAll('script,style,link,meta,head,nav,aside');
  removeEls.forEach(s => s.remove());

  let root = tempDiv.querySelector('body') || tempDiv;

  const allBlocks = root.querySelectorAll('p,h1,h2,h3,h4,h5,h6,div,li,blockquote,td,th,dt,dd,figcaption,pre,article,section');
  const textParts = [];
  const seen = new Set();
  for (const b of allBlocks) {
    const text = b.textContent.trim();
    if (text.length > 0 && !seen.has(text)) {
      const childBlocks = b.querySelectorAll('p,h1,h2,h3,h4,h5,h6,div,li,blockquote');
      if (childBlocks.length === 0) {
        seen.add(text);
        textParts.push(text);
      }
    }
  }

  if (textParts.length > 0) return textParts.join('\n\n');
  return root.textContent?.trim() || '';
}

function segmentText(text) {
  const raw = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  let segments = raw.split(/\n\s*\n/).map(s => s.trim()).filter(s => s.length > 0);
  if (segments.length <= 1 && raw.length > 500) {
    segments = raw.split(/\n/).map(s => s.trim()).filter(s => s.length > 0);
  }
  if (segments.length === 0) {
    segments = [raw.trim()];
  }
  const merged = [];
  let current = '';
  for (const seg of segments) {
    if (current.length + seg.length < 80 && seg.length < 40) {
      current = current ? current + '\n' + seg : seg;
    } else {
      if (current) merged.push(current);
      current = seg;
    }
  }
  if (current) merged.push(current);

  return merged.map((text, i) => ({
    id: i,
    source: text,
    status: 'pending',
    translations: [],
    selectedIndex: -1,
    userFinal: '',
    previousOptions: [],
    chapterId: 0,
    chapterTitle: 'All Segments',
  }));
}

// ============================================================
// AI-DRIVEN CHAPTER DETECTION — Multi-signal cross-referencing
// ============================================================
// This system uses three cross-verifiable indicators:
// 1. EPUB's own TOC (NCX/nav) — the book's declared structure
// 2. Hyperlinks in content — text with <a href> often = TOC entries pointing to chapters
// 3. Heading tags (h1-h6) and heading-like CSS classes — structural styling
//
// The AI is asked to deliberate slowly, comparing these signals segment by segment,
// rather than making a single fast pass.

async function detectChaptersWithAI(segments, modelId) {
  if (segments.length <= 10) {
    segments.forEach(s => { s.chapterId = 1; s.chapterTitle = 'All Segments'; });
    return segments;
  }

  // --- Gather all structural evidence ---
  const epubToc = segments._epubToc || [];
  const structuredBlocks = segments._structuredBlocks || [];

  // Build a rich evidence report for the AI
  let evidenceReport = '';

  // Evidence 1: EPUB TOC (from NCX or nav document)
  if (epubToc.length > 0) {
    evidenceReport += `\n=== EVIDENCE 1: EPUB Table of Contents (from book metadata) ===\n`;
    evidenceReport += `The book declares ${epubToc.length} TOC entries:\n`;
    for (let i = 0; i < epubToc.length; i++) {
      evidenceReport += `  TOC[${i}]: "${epubToc[i].title}" → ${epubToc[i].href || '(no href)'}\n`;
    }
    evidenceReport += `\nThis is the book's OWN declaration of its structure. Treat these as HIGH CONFIDENCE chapter boundaries.\n`;
  }

  // Evidence 2: Segments with heading tags or heading-like styles
  const headingSegments = [];
  for (let i = 0; i < segments.length; i++) {
    const meta = segments[i]._meta;
    if (meta && (meta.hasHeading || meta.hasHeadingStyle)) {
      headingSegments.push({
        idx: i,
        text: segments[i].source.substring(0, 100),
        tag: meta.headingTag || '(styled)',
        tocMatch: meta.tocMatch || null,
      });
    }
  }
  if (headingSegments.length > 0) {
    evidenceReport += `\n=== EVIDENCE 2: Segments with Heading Tags/Styles ===\n`;
    evidenceReport += `Found ${headingSegments.length} segments that use <h1>-<h6> tags or heading CSS classes:\n`;
    for (const h of headingSegments) {
      const matchNote = h.tocMatch ? ` [MATCHES TOC: "${h.tocMatch}"]` : '';
      evidenceReport += `  Segment[${h.idx}] <${h.tag}>: "${h.text}"${matchNote}\n`;
    }
    evidenceReport += `\nHeading tags strongly indicate chapter/section boundaries.\n`;
  }

  // Evidence 3: Segments with hyperlinks (often found in TOC pages within the book)
  const linkSegments = [];
  for (let i = 0; i < segments.length; i++) {
    const meta = segments[i]._meta;
    if (meta && meta.hasLink) {
      linkSegments.push({
        idx: i,
        text: segments[i].source.substring(0, 100),
      });
    }
  }
  if (linkSegments.length > 0 && linkSegments.length <= 50) {
    evidenceReport += `\n=== EVIDENCE 3: Segments Containing Hyperlinks ===\n`;
    evidenceReport += `Found ${linkSegments.length} segments with <a href> links. In EPUB files, hyperlinked text in the content or TOC area is very likely a chapter title or section reference:\n`;
    for (const l of linkSegments.slice(0, 30)) {
      evidenceReport += `  Segment[${l.idx}]: "${l.text}"\n`;
    }
    if (linkSegments.length > 30) {
      evidenceReport += `  ... (${linkSegments.length - 30} more)\n`;
    }
  }

  // Evidence 4: TOC-matched segments
  const tocMatchedSegments = [];
  for (let i = 0; i < segments.length; i++) {
    const meta = segments[i]._meta;
    if (meta && meta.tocMatch) {
      tocMatchedSegments.push({
        idx: i,
        text: segments[i].source.substring(0, 100),
        tocTitle: meta.tocMatch,
      });
    }
  }
  if (tocMatchedSegments.length > 0) {
    evidenceReport += `\n=== EVIDENCE 4: Segments Matching TOC Titles ===\n`;
    evidenceReport += `These segments have text that directly matches an EPUB TOC entry — strongest signal:\n`;
    for (const tm of tocMatchedSegments) {
      evidenceReport += `  Segment[${tm.idx}]: "${tm.text}" ← matches TOC title "${tm.tocTitle}"\n`;
    }
  }

  // Evidence 5: Spine file boundaries
  const spineChanges = [];
  let prevSpine = -1;
  for (let i = 0; i < segments.length; i++) {
    const meta = segments[i]._meta;
    if (meta && meta.spineIndex !== prevSpine && meta.spineIndex >= 0) {
      spineChanges.push({ idx: i, file: meta.spineFile, spineIdx: meta.spineIndex });
      prevSpine = meta.spineIndex;
    }
  }
  if (spineChanges.length > 1 && spineChanges.length <= 100) {
    evidenceReport += `\n=== EVIDENCE 5: EPUB Spine File Boundaries ===\n`;
    evidenceReport += `The EPUB has ${spineChanges.length} separate content files in its spine. A new file often (but not always) means a new chapter:\n`;
    for (const sc of spineChanges.slice(0, 50)) {
      evidenceReport += `  Segment[${sc.idx}]: starts file "${sc.file.split('/').pop()}"\n`;
    }
    if (spineChanges.length > 50) {
      evidenceReport += `  ... (${spineChanges.length - 50} more)\n`;
    }
  }

  // --- Also scan for in-text TOC (for formats without proper EPUB metadata) ---
  let inTextToc = '';
  const tocKeywords = [
    /^contents$/i, /^table\s+of\s+contents$/i, /^目录$/,
    /^toc$/i, /^catalogue$/i, /^索引$/, /^目\s*次$/
  ];
  const searchLimit = Math.min(segments.length, Math.max(30, Math.floor(segments.length * 0.15)));
  for (let i = 0; i < searchLimit; i++) {
    const src = segments[i].source.trim();
    const firstLine = src.split('\n')[0].trim();
    const isTocHeading = tocKeywords.some(rx => rx.test(firstLine));
    if (isTocHeading) {
      inTextToc = src;
      for (let j = i + 1; j < Math.min(i + 15, segments.length); j++) {
        const nextSrc = segments[j].source.trim();
        const nextLines = nextSrc.split('\n');
        const looksLikeToc = nextLines.every(l => l.trim().length < 120) && nextLines.length <= 40;
        if (looksLikeToc && !tocKeywords.some(rx => rx.test(nextLines[0].trim()))) {
          inTextToc += '\n' + nextSrc;
        } else { break; }
      }
      break;
    }
    // Structural TOC detection
    if (src.length > 100) {
      const srcLines = src.split('\n').filter(l => l.trim());
      if (srcLines.length >= 4) {
        const tocLikeLines = srcLines.filter(l => {
          const t = l.trim();
          return t.length < 100 && (
            /\d+\s*$/.test(t) || /\.{3,}/.test(t) || /…{2,}/.test(t) ||
            /^(chapter|part|section|\d+[\.\):]|第.{1,3}[章节部篇回])/i.test(t)
          );
        });
        if (tocLikeLines.length >= srcLines.length * 0.5 && srcLines.length >= 5) {
          inTextToc = src;
          break;
        }
      }
    }
  }
  if (inTextToc) {
    const truncatedInTextToc = inTextToc.length > 2000 ? inTextToc.substring(0, 2000) + '\n...(truncated)' : inTextToc;
    evidenceReport += `\n=== EVIDENCE 6: In-Text Table of Contents ===\n`;
    evidenceReport += `A table of contents was found within the book's text content:\n`;
    evidenceReport += `--- IN-TEXT TOC ---\n${truncatedInTextToc}\n--- END ---\n`;
  }

  // --- Build segment listing for AI ---
  const lines = segments.map((s, i) => {
    const meta = s._meta || {};
    let flags = [];
    if (meta.hasHeading) flags.push(`<${meta.headingTag}>`);
    else if (meta.hasHeadingStyle) flags.push('[heading-style]');
    if (meta.hasLink) flags.push('[has-links]');
    if (meta.tocMatch) flags.push(`[toc:"${meta.tocMatch}"]`);
    const flagStr = flags.length > 0 ? ' ' + flags.join(' ') : '';
    const firstLine = s.source.split('\n')[0].trim();
    return `[${i}]${flagStr} ${firstLine.substring(0, 80)}`;
  });

  // Split into batches if necessary — for very long books, send all segment info
  let segmentList = '';
  for (const line of lines) {
    if (segmentList.length + line.length > 8000) {
      segmentList += `\n... (${lines.length - segmentList.split('\n').length} more segments)`;
      break;
    }
    segmentList += line + '\n';
  }

  // --- Build the AI prompt ---
  const prompt = `You are an expert book structural analyst. Your task is to identify the exact chapter/section boundaries of a book that has been parsed into ${segments.length} text segments.

You have MULTIPLE sources of evidence to cross-reference. Compare them carefully against each other to achieve HIGH ACCURACY.

${evidenceReport}

=== FULL SEGMENT LISTING ===
Each line shows: [segment_index] [structural_flags] first_line_of_text
Flags: <h1>-<h6> = HTML heading tag, [heading-style] = CSS heading class, [has-links] = contains hyperlinks, [toc:"..."] = matches a TOC entry.

${segmentList}

=== YOUR TASK ===
Cross-reference ALL the evidence above to determine the book's chapter structure. Follow this process:

STEP 1: If EPUB TOC exists (Evidence 1), use it as the PRIMARY skeleton. Each TOC entry should map to exactly one chapter boundary.

STEP 2: For each TOC entry, find the corresponding segment by checking:
  - Segments flagged with [toc:"..."] (Evidence 4) — strongest match
  - Segments with heading tags <h1>/<h2> whose text matches the TOC title (Evidence 2)
  - Segments at spine file boundaries (Evidence 5) where the file matches the TOC href

STEP 3: Validate using heading tags (Evidence 2). Every <h1> or <h2> that is NOT already matched to a TOC entry might indicate a sub-section or unlisted chapter.

STEP 4: Check for segments with [has-links] near the beginning — these might be in-book TOC pages that should be grouped as "Front Matter", not individual chapters.

STEP 5: Handle front matter (title page, copyright, dedication, TOC page itself) and back matter (appendix, index, acknowledgments) as separate sections.

Return ONLY valid JSON (no markdown fences):
{"chapters": [{"start": 0, "title": "Chapter title"}, {"start": N, "title": "Next chapter"}, ...]}

Rules:
- "start" = the segment index where a new chapter begins
- First entry must start at 0
- Use the book's own chapter titles (from TOC or heading text), not invented names
- Every EPUB TOC entry should appear as a chapter boundary unless it's clearly a sub-section
- If no structural signals exist, fall back to content-based grouping (10-50 segments per chapter)
- Front/back matter should have descriptive titles like "Front Matter", "Afterword", etc.`;

  try {
    const resp = await puter.ai.chat(prompt, { model: modelId, temperature: 0.3 });
    const text = extractTextFromAIResponse(resp);
    if (!text) throw new Error('Empty AI response');

    let jsonStr = text.trim().replace(/^```(?:json)?\s*\n?/i, '').replace(/\n?```\s*$/i, '');
    const parsed = JSON.parse(jsonStr);

    if (parsed.chapters && Array.isArray(parsed.chapters) && parsed.chapters.length > 0) {
      const chapters = parsed.chapters
        .filter(c => typeof c.start === 'number' && c.title)
        .sort((a, b) => a.start - b.start);

      if (chapters.length > 0) {
        if (chapters[0].start !== 0) {
          chapters.unshift({ start: 0, title: 'Front Matter' });
        }

        for (let i = 0; i < segments.length; i++) {
          let chIdx = 0;
          for (let c = chapters.length - 1; c >= 0; c--) {
            if (i >= chapters[c].start) {
              chIdx = c;
              break;
            }
          }
          segments[i].chapterId = chIdx + 1;
          segments[i].chapterTitle = chapters[chIdx].title;
        }

        // --- VALIDATION PASS: If EPUB TOC exists, verify coverage ---
        if (epubToc.length > 0 && chapters.length >= 2) {
          const matchedTocTitles = new Set(chapters.map(c => c.title.toLowerCase().trim()));
          const unmatchedToc = epubToc.filter(t => {
            const titleLower = t.title.toLowerCase().trim();
            return !matchedTocTitles.has(titleLower) &&
                   ![...matchedTocTitles].some(mt => mt.includes(titleLower) || titleLower.includes(mt));
          });

          if (unmatchedToc.length > 0 && unmatchedToc.length <= 5) {
            console.log(`[TransLoom] ${unmatchedToc.length} EPUB TOC entries not matched to chapters:`,
              unmatchedToc.map(t => t.title));
          }
        }

        return segments;
      }
    }
  } catch (e) {
    console.warn('AI chapter detection failed, using structural fallback:', e);
  }

  // --- Structural fallback: use heading/TOC signals without AI ---
  return structuralFallbackGrouping(segments);
}

// Fallback that uses structural metadata if AI fails
function structuralFallbackGrouping(segments) {
  // Try to group by structural signals first
  const chapterBoundaries = [];

  for (let i = 0; i < segments.length; i++) {
    const meta = segments[i]._meta;
    if (meta) {
      // Strong signal: TOC match or h1/h2 heading
      if (meta.tocMatch || (meta.hasHeading && (meta.headingTag === 'h1' || meta.headingTag === 'h2'))) {
        chapterBoundaries.push({
          start: i,
          title: meta.tocMatch || segments[i].source.split('\n')[0].trim().substring(0, 80),
        });
      }
    }
  }

  if (chapterBoundaries.length >= 2) {
    // We found structural chapters
    if (chapterBoundaries[0].start !== 0) {
      chapterBoundaries.unshift({ start: 0, title: 'Front Matter' });
    }
    for (let i = 0; i < segments.length; i++) {
      let chIdx = 0;
      for (let c = chapterBoundaries.length - 1; c >= 0; c--) {
        if (i >= chapterBoundaries[c].start) {
          chIdx = c;
          break;
        }
      }
      segments[i].chapterId = chIdx + 1;
      segments[i].chapterTitle = chapterBoundaries[chIdx].title;
    }
    return segments;
  }

  // Last resort: fixed-size grouping
  return fixedSizeGrouping(segments);
}

function fixedSizeGrouping(segments) {
  const GROUP_SIZE = 20;
  if (segments.length <= GROUP_SIZE) {
    segments.forEach(s => { s.chapterId = 1; s.chapterTitle = 'All Segments'; });
    return segments;
  }
  let sectionNum = 0;
  for (let i = 0; i < segments.length; i++) {
    if (i % GROUP_SIZE === 0) sectionNum++;
    const start = Math.floor(i / GROUP_SIZE) * GROUP_SIZE + 1;
    const end = Math.min(start + GROUP_SIZE - 1, segments.length);
    segments[i].chapterId = sectionNum;
    segments[i].chapterTitle = `Section ${sectionNum} (${start}–${end})`;
  }
  return segments;
}

// ============================================================
// SECTION: PROGRESS FILE — HASH & MATCHING UTILITIES
// ============================================================
const TLPROG_FORMAT_VERSION = 1;

function normalizeForHash(text) {
  return text
    .replace(/\s+/g, ' ')
    .replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '')
    .trim()
    .toLowerCase();
}

function computeSegmentHash(text) {
  const n = normalizeForHash(text);
  let h = 0x811c9dc5;
  for (let i = 0; i < n.length; i++) {
    h ^= n.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return (h >>> 0).toString(16).padStart(8, '0');
}

function buildTrigrams(text) {
  const n = normalizeForHash(text);
  const set = new Set();
  for (let i = 0; i <= n.length - 3; i++) set.add(n.substring(i, i + 3));
  return set;
}

function trigramSimilarity(a, b) {
  const na = normalizeForHash(a);
  const nb = normalizeForHash(b);
  if (na.length === 0 && nb.length === 0) return 1;
  if (na.length === 0 || nb.length === 0) return 0;
  if (Math.abs(na.length - nb.length) / Math.max(na.length, nb.length) > 0.5) return 0;
  const ta = buildTrigrams(a);
  const tb = buildTrigrams(b);
  if (ta.size === 0 && tb.size === 0) return 1;
  let inter = 0;
  for (const t of ta) if (tb.has(t)) inter++;
  const union = ta.size + tb.size - inter;
  return union === 0 ? 0 : inter / union;
}

function matchProgressToSegments(newSegments, progressData) {
  const progSegs = progressData.segments;
  const results = new Array(newSegments.length).fill(null).map(() => ({
    matchType: 'unmatched', confidence: 0, progressSegmentId: null, needsReview: false,
  }));

  // Build hash map from progress segments (handle duplicate hashes with position arrays)
  const hashMap = {};
  for (let i = 0; i < progSegs.length; i++) {
    const h = progSegs[i].sourceHash;
    if (!hashMap[h]) hashMap[h] = [];
    hashMap[h].push(i);
  }

  const matchedProg = new Set();
  const matchedNew = new Set();

  // — Tier 1: exact hash match —
  for (let i = 0; i < newSegments.length; i++) {
    const hash = computeSegmentHash(newSegments[i].source);
    const candidates = hashMap[hash];
    if (!candidates || candidates.length === 0) continue;

    // Pick best candidate: prefer same position, then closest position
    let bestIdx = null;
    let bestDist = Infinity;
    for (const ci of candidates) {
      if (matchedProg.has(ci)) continue;
      // Secondary check: length must be within 5%
      const progLen = progSegs[ci].sourceLength || 0;
      const newLen = newSegments[i].source.length;
      if (progLen > 0 && Math.abs(progLen - newLen) / Math.max(progLen, newLen) > 0.05) continue;
      const dist = Math.abs(i - progSegs[ci].id);
      if (dist < bestDist) { bestDist = dist; bestIdx = ci; }
    }

    if (bestIdx !== null) {
      results[i] = { matchType: 'exact', confidence: 1.0, progressSegmentId: bestIdx, needsReview: false };
      matchedProg.add(bestIdx);
      matchedNew.add(i);
    }
  }

  // — Tier 2: fuzzy match (only for unmatched, cap at 200) —
  const unmatchedNew = [];
  for (let i = 0; i < newSegments.length; i++) {
    if (!matchedNew.has(i)) unmatchedNew.push(i);
  }
  const unmatchedProg = [];
  for (let i = 0; i < progSegs.length; i++) {
    if (!matchedProg.has(i)) unmatchedProg.push(i);
  }

  if (unmatchedNew.length <= 200 && unmatchedProg.length <= 200) {
    for (const ni of unmatchedNew) {
      if (matchedNew.has(ni)) continue;
      let bestSim = 0;
      let bestPi = null;
      for (const pi of unmatchedProg) {
        if (matchedProg.has(pi)) continue;
        const sim = trigramSimilarity(newSegments[ni].source, progSegs[pi].sourcePrefix || '');
        // If prefix is short, also compare with full text if available in preferences
        if (sim > bestSim) { bestSim = sim; bestPi = pi; }
      }
      if (bestSim >= 0.4 && bestPi !== null) {
        results[ni] = {
          matchType: 'fuzzy',
          confidence: bestSim,
          progressSegmentId: bestPi,
          needsReview: bestSim < 0.7,
        };
        matchedProg.add(bestPi);
        matchedNew.add(ni);
      }
    }
  }

  // — Tier 3: positional fallback (±3 window) —
  for (let i = 0; i < newSegments.length; i++) {
    if (matchedNew.has(i)) continue;
    let bestSim = 0;
    let bestPi = null;
    for (let offset = -3; offset <= 3; offset++) {
      const pi = i + offset;
      if (pi < 0 || pi >= progSegs.length || matchedProg.has(pi)) continue;
      // Use sourcePrefix for comparison (max 80 chars stored)
      const sim = trigramSimilarity(
        newSegments[i].source.substring(0, 80),
        (progSegs[pi].sourcePrefix || '').substring(0, 80)
      );
      if (sim > bestSim) { bestSim = sim; bestPi = pi; }
    }
    if (bestSim >= 0.35 && bestPi !== null) {
      results[i] = {
        matchType: 'positional',
        confidence: bestSim,
        progressSegmentId: bestPi,
        needsReview: true,
      };
      matchedProg.add(bestPi);
      matchedNew.add(i);
    }
  }

  return results;
}

// ============================================================
// SECTION: PROGRESS FILE — EXPORT & IMPORT
// ============================================================
async function exportProgress() {
  if (!AppState.project) { showToast('No active project', 'warning'); return; }
  try {
    const p = AppState.project;
    const prefs = await dbGetByIndex(STORE_PREFS, 'projectId', p.id);

    const data = {
      formatVersion: TLPROG_FORMAT_VERSION,
      exportedAt: Date.now(),
      project: {
        name: p.name,
        sourceLang: p.sourceLang,
        targetLang: p.targetLang,
        modelId: p.modelId,
        createdAt: p.createdAt,
      },
      preferencePrompt: p.preferencePrompt || '',
      styleProfile: p.styleProfile || null,
      glossary: p.glossary || {},
      typographySettings: p.typographySettings || { ...AppState.typography },
      headingStyles: p.headingStyles || { ...AppState.headingStyles },
      paraSettings: { ...AppState.paraSettings },
      segments: p.segments.map(s => ({
        id: s.id,
        source: s.source,
        sourceHash: computeSegmentHash(s.source),
        sourcePrefix: s.source.substring(0, 80),
        sourceLength: s.source.length,
        status: s.status,
        translations: s.translations || [],
        selectedIndex: s.selectedIndex,
        userFinal: s.userFinal || '',
        previousOptions: s.previousOptions || [],
        chapterId: s.chapterId,
        chapterTitle: s.chapterTitle,
        sourceHtml: s.sourceHtml || '',
        _meta: s._meta || null,
      })),
      preferences: prefs.map(pr => ({
        segmentId: pr.segmentId,
        source: pr.source,
        aiOptions: pr.aiOptions,
        userFinal: pr.userFinal,
        timestamp: pr.timestamp,
        styleFeatures: pr.styleFeatures,
      })),
    };

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    await downloadBlob(blob, (p.name || 'translation') + '.tlprog');

    const completed = p.segments.filter(s => s.status === 'completed').length;
    showToast(`Progress saved (${completed}/${p.segments.length} segments)`, 'success');
  } catch (e) {
    showToast('Export failed: ' + e.message, 'error');
  }
}

function importProgressFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        // Validate
        if (!data.formatVersion) throw new Error('Missing formatVersion — not a valid .tlprog file');
        if (data.formatVersion > TLPROG_FORMAT_VERSION) throw new Error(`File format version ${data.formatVersion} is newer than this app supports`);
        if (!Array.isArray(data.segments) || data.segments.length === 0) throw new Error('No segment data found in progress file');
        // Validate segment entries
        for (let i = 0; i < Math.min(data.segments.length, 5); i++) {
          const s = data.segments[i];
          if (typeof s.sourceHash !== 'string') throw new Error(`Segment ${i} missing sourceHash`);
        }
        resolve(data);
      } catch (err) {
        reject(new Error('Invalid progress file: ' + err.message));
      }
    };
    reader.onerror = () => reject(new Error('Failed to read progress file'));
    reader.readAsText(file);
  });
}

// ============================================================
// SECTION: AI SERVICE LAYER
// ============================================================

// callAI now supports both legacy string prompts and structured messages arrays.
// Options: { model, temperature, maxTokens }
async function callAI(promptOrMessages, options = {}) {
  const provider = AppState.aiProvider || 'puter';

  // Manual mode - throw error to let callers handle gracefully
  if (provider === 'manual') {
    throw new Error('AI is disabled (Manual Only mode). Write your own translations.');
  }

  const model = options.model || AppState.project?.modelId || 'gpt-4o';

  // Try puter.js first if selected
  if (provider === 'puter') {
    try {
      return await _callPuter(promptOrMessages, model, options);
    } catch (puterErr) {
      console.warn('Puter.js call failed, checking for API key fallback:', puterErr);
      // If user has a stored API key, fall back
      if (AppState.apiKey) {
        const fbProvider = AppState.apiKey.startsWith('sk-ant-') ? 'anthropic' : 'openai';
        showToast('Puter.js unavailable, using ' + fbProvider + ' fallback', 'warning');
        return await _callDirect(fbProvider, promptOrMessages, model, options);
      }
      throw puterErr;
    }
  }

  // Direct API call for openai/anthropic providers
  return await _callDirect(provider, promptOrMessages, model, options);
}

async function _callPuter(promptOrMessages, model, options) {
  const chatOpts = { model };
  if (typeof options.temperature === 'number') chatOpts.temperature = options.temperature;
  if (typeof options.maxTokens === 'number') chatOpts.max_tokens = options.maxTokens;
  const resp = await puter.ai.chat(promptOrMessages, chatOpts);
  const text = extractTextFromAIResponse(resp);
  if (!text) throw new Error('Empty response from AI model');
  return text;
}

async function _callDirect(provider, promptOrMessages, model, options) {
  const apiKey = AppState.apiKey;
  if (!apiKey) throw new Error('No API key configured for ' + provider + '. Go to Settings to add one.');

  const messages = Array.isArray(promptOrMessages)
    ? promptOrMessages
    : [{ role: 'user', content: promptOrMessages }];

  if (provider === 'openai') {
    const body = { model: model || 'gpt-4o', messages };
    if (typeof options.temperature === 'number') body.temperature = options.temperature;
    if (typeof options.maxTokens === 'number') body.max_tokens = options.maxTokens;

    const resp = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + apiKey },
      body: JSON.stringify(body)
    });
    if (!resp.ok) { const err = await resp.text(); throw new Error('OpenAI API error: ' + resp.status + ' - ' + err.substring(0, 200)); }
    const data = await resp.json();
    return data.choices?.[0]?.message?.content || '';
  }

  if (provider === 'anthropic') {
    const systemMsgs = messages.filter(m => m.role === 'system');
    const userMsgs = messages.filter(m => m.role !== 'system');
    const body = {
      model: model || 'claude-sonnet-4-20250514',
      max_tokens: options.maxTokens || 4000,
      messages: userMsgs
    };
    if (systemMsgs.length > 0) body.system = systemMsgs.map(m => m.content).join('\n');
    if (typeof options.temperature === 'number') body.temperature = options.temperature;

    const resp = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify(body)
    });
    if (!resp.ok) { const err = await resp.text(); throw new Error('Anthropic API error: ' + resp.status + ' - ' + err.substring(0, 200)); }
    const data = await resp.json();
    return data.content?.map(c => c.text || '').join('') || '';
  }

  throw new Error('Unknown provider: ' + provider);
}

// Build context window: prev 2 confirmed translations + next 2 source texts
function buildContextWindow(segmentIndex) {
  const segs = AppState.project?.segments;
  if (!segs) return { prevTranslations: [], nextSources: [] };

  const prevTranslations = [];
  for (let i = segmentIndex - 1; i >= Math.max(0, segmentIndex - 2); i--) {
    if (segs[i].status === 'completed' && segs[i].userFinal) {
      prevTranslations.unshift({ source: segs[i].source.substring(0, 200), translation: segs[i].userFinal.substring(0, 200) });
    }
  }

  const nextSources = [];
  for (let i = segmentIndex + 1; i <= Math.min(segs.length - 1, segmentIndex + 2); i++) {
    nextSources.push(segs[i].source.substring(0, 200));
  }

  return { prevTranslations, nextSources };
}

function extractTextFromAIResponse(resp) {
  if (!resp) return '';
  if (typeof resp === 'string') return resp;
  // Puter.js may return { message: { content: "..." } }
  if (resp.message?.content) {
    if (typeof resp.message.content === 'string') return resp.message.content;
    // content can be an array of parts (Anthropic-style)
    if (Array.isArray(resp.message.content)) {
      return resp.message.content
        .map(p => (typeof p === 'string' ? p : p?.text || ''))
        .join('');
    }
  }
  // { text: "..." }
  if (typeof resp.text === 'string') return resp.text;
  // { content: "..." } or { content: [{ text: "..." }] }
  if (resp.content) {
    if (typeof resp.content === 'string') return resp.content;
    if (Array.isArray(resp.content)) {
      return resp.content
        .map(p => (typeof p === 'string' ? p : p?.text || ''))
        .join('');
    }
  }
  // Array of choices: [{ message: { content: "..." } }]
  if (Array.isArray(resp) && resp.length > 0) {
    return extractTextFromAIResponse(resp[0]);
  }
  // { choices: [{ message: { content: "..." } }] } (OpenAI-style)
  if (resp.choices?.[0]) {
    return extractTextFromAIResponse(resp.choices[0]);
  }
  // Last resort
  const str = JSON.stringify(resp);
  console.warn('callAI: unrecognized response shape, stringified:', str.substring(0, 200));
  return str;
}

function getSourceLangLabel() {
  const l = LANGUAGES.find(l => l.code === AppState.project.sourceLang);
  return l ? l.label : AppState.project.sourceLang;
}

function getTargetLangLabel() {
  const l = LANGUAGES.find(l => l.code === AppState.project.targetLang);
  return l ? l.label : AppState.project.targetLang;
}

async function generateTranslations(sourceText, instructions, segmentIndex) {
  const prefPrompt = AppState.project.preferencePrompt || '';
  const prefSection = prefPrompt ? `\n[User Style Preferences]: ${prefPrompt}\n` : '';
  const instructSection = instructions ? `\n[Additional Instructions]: ${instructions}\n` : '';

  // Build context window
  const ctx = buildContextWindow(typeof segmentIndex === 'number' ? segmentIndex : AppState.currentSegmentIndex);

  let contextSection = '';
  if (ctx.prevTranslations.length > 0) {
    contextSection += '\n[Previous confirmed translations for continuity]:\n';
    for (const pt of ctx.prevTranslations) {
      contextSection += `  Source: "${pt.source}"\n  Translation: "${pt.translation}"\n\n`;
    }
  }
  if (ctx.nextSources.length > 0) {
    contextSection += '[Upcoming source text for context]:\n';
    for (const ns of ctx.nextSources) {
      contextSection += `  "${ns}"\n`;
    }
    contextSection += '\n';
  }

  // Glossary injection
  const glossary = AppState.project.glossary || {};
  const glossaryEntries = Object.entries(glossary);
  let glossarySection = '';
  if (glossaryEntries.length > 0) {
    // Only inject relevant glossary entries (terms that appear in source text)
    const relevantEntries = glossaryEntries.filter(([src]) =>
      sourceText.toLowerCase().includes(src.toLowerCase())
    );
    if (relevantEntries.length > 0) {
      glossarySection = '\n[Glossary — you MUST use these translations for the specified terms]:\n';
      for (const [src, tgt] of relevantEntries) {
        glossarySection += `  "${src}" → "${tgt}"\n`;
      }
      glossarySection += '\n';
    }
  }

  // Build messages array
  const systemMsg = `You are an expert literary translator from ${getSourceLangLabel()} to ${getTargetLangLabel()}.${prefSection}${glossarySection}${contextSection}${instructSection}
IMPORTANT: All proper nouns, character names, place names, and brand names MUST be kept in their original form — do NOT transliterate or translate them.

When translating, prioritize producing text that sounds like it was originally written in ${getTargetLangLabel()} by a native speaker. Avoid translationese — do not mirror the source grammar or word order when it would sound unnatural. Use idiomatic expressions, natural sentence rhythms, and culturally appropriate phrasing in ${getTargetLangLabel()}.

Provide exactly 3 different translation options:
1. A faithful/literal translation that preserves the original structure
2. A natural/fluent translation that reads smoothly and idiomatically in ${getTargetLangLabel()}, as if written by a native speaker
3. A creative/literary translation with stylistic flair and expressive language

Return ONLY valid JSON in this exact format (no markdown fences):
{"options": ["translation 1", "translation 2", "translation 3"]}`;

  const messages = [
    { role: 'system', content: systemMsg },
    { role: 'user', content: `Translate this text:\n\n${sourceText}` },
  ];

  const response = await callAI(messages, { temperature: 0.3, maxTokens: 2000 });
  // Ensure response is a string before processing
  const responseStr = typeof response === 'string' ? response : String(response || '');
  try {
    let jsonStr = responseStr.trim();
    jsonStr = jsonStr.replace(/^```(?:json)?\s*\n?/i, '').replace(/\n?```\s*$/i, '');
    const parsed = JSON.parse(jsonStr);
    if (parsed.options && Array.isArray(parsed.options)) {
      return parsed.options.filter(o => typeof o === 'string' && o.trim()).slice(0, 3);
    }
  } catch (e) {
    console.warn('JSON parse failed, trying to extract options:', e);
  }
  // Fallback: split by numbered lines (1. ... 2. ... 3. ...)
  const numbered = responseStr.match(/(?:^|\n)\s*\d+[\.\)]\s*(.+)/g);
  if (numbered && numbered.length >= 2) {
    return numbered.map(l => l.replace(/^\s*\d+[\.\)]\s*/, '').trim()).filter(Boolean).slice(0, 3);
  }
  const lines = responseStr.split('\n').filter(l => l.trim().length > 10);
  if (lines.length >= 2) return lines.slice(0, 3);
  return [responseStr.trim() || 'Translation unavailable — please try regenerating.'];
}

async function analyzeStylePreferences(preferences) {
  const samples = preferences.slice(-9).map(p => ({
    source: p.source.substring(0, 100),
    userChoice: p.userFinal.substring(0, 150),
  }));

  const messages = [
    { role: 'system', content: `You are a translation style analyst. Analyze translation choices and produce a structured style profile as JSON.` },
    { role: 'user', content: `Analyze these translation choices made by a user translating from ${getSourceLangLabel()} to ${getTargetLangLabel()}. Identify their translation style preferences.

${JSON.stringify(samples, null, 2)}

Return ONLY valid JSON in this exact format (no markdown fences):
{
  "formality_level": <number 1-5, where 1=very informal, 5=very formal>,
  "sentence_length": "<short|medium|long>",
  "vocabulary": "<simple|literary|technical|mixed>",
  "tone": "<neutral|warm|poetic|direct>",
  "structure_preference": "<literal|natural|creative>",
  "notable_patterns": ["<pattern1>", "<pattern2>"],
  "style_guide": "<2-3 sentence summary for future translations>"
}` },
  ];

  const resp = await callAI(messages, { temperature: 0.7 });

  // Parse the structured profile
  try {
    let jsonStr = resp.trim().replace(/^```(?:json)?\s*\n?/i, '').replace(/\n?```\s*$/i, '');
    const parsed = JSON.parse(jsonStr);
    return parsed;
  } catch (e) {
    console.warn('Style profile JSON parse failed, using text fallback:', e);
    return { style_guide: resp, formality_level: 3, sentence_length: 'medium', vocabulary: 'mixed', tone: 'neutral', structure_preference: 'natural', notable_patterns: [] };
  }
}

async function popupAIEdit(selectedText, instruction) {
  const prefPrompt = AppState.project.preferencePrompt || '';
  const prefSection = prefPrompt ? `\n[User Style Preferences]: ${prefPrompt}\n` : '';

  const messages = [
    { role: 'system', content: `You are an expert literary editor working on a ${getTargetLangLabel()} translation.${prefSection}\nProvide an improved version of the selected text. Return ONLY the improved text, nothing else.` },
    { role: 'user', content: `Selected text from translation:\n"${selectedText}"\n\nRequest: ${instruction}` },
  ];

  return await callAI(messages, { temperature: 0.7 });
}

// ============================================================
// SECTION: PREFERENCE & LEARNING ENGINE
// ============================================================
async function recordPreference(segment) {
  const pref = {
    projectId: AppState.project.id,
    segmentId: segment.id,
    source: segment.source,
    aiOptions: [...segment.translations],
    userFinal: segment.userFinal,
    timestamp: Date.now(),
    styleFeatures: detectStyleFeatures(segment.source, segment.userFinal),
  };
  await dbPut(STORE_PREFS, pref);

  AppState.confirmedCount++;
  if (AppState.confirmedCount % PREF_ANALYSIS_INTERVAL === 0) {
    // Run preference analysis in background — don't block the confirm flow
    updatePreferencePrompt().catch(e => console.warn('Preference analysis failed:', e));
  }
}

function detectStyleFeatures(source, translation) {
  const features = [];
  const avgSentLen = translation.split(/[.!?。！？]/).filter(s => s.trim()).length;
  if (avgSentLen > 3) features.push('short_sentences');
  else features.push('long_sentences');

  if (/[\u4e00-\u9fff]/.test(translation)) {
    if (/[\u3001\u3002]/.test(translation)) features.push('chinese_punctuation');
    if (translation.length < source.length * 0.8) features.push('concise');
    if (/[\u6210\u8bed\u4e09\u5b57\u7ecf]/.test(translation)) features.push('idiomatic');
  }

  if (translation.match(/\b(shall|whom|hereby|thus|therefore)\b/i)) features.push('formal');
  if (translation.match(/\b(gonna|wanna|kinda|gotta)\b/i)) features.push('informal');

  return features;
}

async function updatePreferencePrompt() {
  try {
    const prefs = await dbGetByIndex(STORE_PREFS, 'projectId', AppState.project.id);
    if (prefs.length < 3) return;
    const profile = await analyzeStylePreferences(prefs);

    // Store structured profile
    AppState.project.styleProfile = profile;

    // Use the style_guide text as the prompt for translations
    const guideText = typeof profile === 'string' ? profile :
      (profile.style_guide || `Formality: ${profile.formality_level}/5, ${profile.tone} tone, ${profile.sentence_length} sentences, ${profile.vocabulary} vocabulary. ${(profile.notable_patterns || []).join('. ')}`);

    AppState.project.preferencePrompt = guideText;
    await saveProject();
    showToast('Style preferences updated');
  } catch (e) {
    console.warn('Preference update failed:', e);
  }
}

// ============================================================
// SECTION: TOAST & UTILITY FUNCTIONS
// ============================================================
function showToast(message, type = 'info') {
  const container = document.getElementById('toast-container');
  const toast = document.createElement('div');
  const colors = {
    info: 'bg-ink-800 text-white',
    success: 'bg-green-600 text-white',
    error: 'bg-red-600 text-white',
    warning: 'bg-amber-500 text-white',
  };
  toast.className = `toast ${colors[type] || colors.info} px-4 py-2.5 rounded-lg text-sm shadow-lg max-w-xs`;
  toast.textContent = message;
  container.appendChild(toast);
  setTimeout(() => toast.remove(), 3000);
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function truncate(str, len) {
  if (!str) return '';
  return str.length > len ? str.substring(0, len) + '...' : str;
}

// ============================================================
// SECTION: UI RENDERING - PHASE 1 (PROJECT CREATION)
// ============================================================
function initPhase1() {
  const sourceSel = document.getElementById('source-lang');
  const targetSel = document.getElementById('target-lang');
  const modelSel = document.getElementById('model-select');

  sourceSel.innerHTML = LANGUAGES.map(l =>
    `<option value="${l.code}">${l.native} (${l.label})</option>`
  ).join('');

  targetSel.innerHTML = LANGUAGES.filter(l => l.code !== 'auto').map(l =>
    `<option value="${l.code}">${l.native} (${l.label})</option>`
  ).join('');
  targetSel.value = 'zh';

  modelSel.innerHTML = buildModelOptions(null);

  const dropZone = document.getElementById('drop-zone');
  const fileInput = document.getElementById('file-input');
  const createBtn = document.getElementById('create-btn');

  dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
  dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
  dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    if (e.dataTransfer.files.length > 0) handleFileSelect(e.dataTransfer.files[0]);
  });

  fileInput.addEventListener('change', (e) => {
    if (e.target.files.length > 0) handleFileSelect(e.target.files[0]);
  });

  createBtn.addEventListener('click', createProject);

  // Progress file upload handling
  const progressInput = document.getElementById('progress-file-input');
  const progressZone = document.getElementById('progress-drop-zone');

  progressZone.addEventListener('dragover', (e) => { e.preventDefault(); progressZone.classList.add('dragover'); });
  progressZone.addEventListener('dragleave', () => progressZone.classList.remove('dragover'));
  progressZone.addEventListener('drop', (e) => {
    e.preventDefault();
    progressZone.classList.remove('dragover');
    if (e.dataTransfer.files.length > 0) handleProgressFileSelect(e.dataTransfer.files[0]);
  });
  progressInput.addEventListener('change', (e) => {
    if (e.target.files.length > 0) handleProgressFileSelect(e.target.files[0]);
  });

  checkForExistingProject();
}

function handleFileSelect(file) {
  const validExts = ['txt', 'docx', 'epub'];
  const ext = file.name.split('.').pop().toLowerCase();
  if (!validExts.includes(ext)) {
    showToast('Unsupported format. Use TXT, DOCX, or EPUB.', 'error');
    return;
  }
  AppState.uploadedFile = file;
  const nameInput = document.getElementById('project-name');
  if (!nameInput.value) {
    nameInput.value = file.name.replace(/\.[^.]+$/, '');
  }
  document.getElementById('file-name-display').textContent = `Selected: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
  document.getElementById('file-name-display').classList.remove('hidden');
  document.getElementById('create-btn').disabled = false;
}

function handleProgressFileSelect(file) {
  const ext = file.name.split('.').pop().toLowerCase();
  if (ext !== 'tlprog') {
    showToast('Please select a .tlprog progress file', 'warning');
    return;
  }
  AppState.uploadedProgressFile = file;
  document.getElementById('progress-file-name').textContent = `${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
  document.getElementById('progress-file-display').classList.remove('hidden');

  // Check if .tlprog has full source text (can resume without book)
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      const hasFullSource = data.segments && data.segments.length > 0 &&
        data.segments.every(s => typeof s.source === 'string' && s.source.length > 0);
      const resumeDiv = document.getElementById('progress-resume-direct');
      if (hasFullSource && resumeDiv) {
        resumeDiv.classList.remove('hidden');
        // Auto-fill project name and languages from progress file
        if (data.project) {
          const nameInput = document.getElementById('project-name');
          if (nameInput && !nameInput.value) nameInput.value = data.project.name || '';
          if (data.project.sourceLang) document.getElementById('source-lang').value = data.project.sourceLang;
          if (data.project.targetLang) document.getElementById('target-lang').value = data.project.targetLang;
          if (data.project.modelId) document.getElementById('model-select').value = data.project.modelId;
        }
      } else if (resumeDiv) {
        resumeDiv.classList.add('hidden');
      }
    } catch (err) {
      console.warn('Could not pre-parse progress file:', err);
    }
  };
  reader.readAsText(file);
  showToast('Progress file loaded', 'info');
}

function clearProgressFile(event) {
  if (event) event.stopPropagation();
  AppState.uploadedProgressFile = null;
  document.getElementById('progress-file-display').classList.add('hidden');
  document.getElementById('progress-resume-direct').classList.add('hidden');
  document.getElementById('progress-file-input').value = '';
}

async function resumeFromProgressOnly() {
  if (!AppState.uploadedProgressFile) {
    showToast('No progress file loaded', 'warning');
    return;
  }

  const btn = document.getElementById('resume-direct-btn');
  const statusEl = document.getElementById('create-status');
  btn.disabled = true;
  btn.textContent = 'Resuming...';
  statusEl.textContent = 'Loading progress file...';
  statusEl.classList.remove('hidden');

  try {
    const progressData = await importProgressFile(AppState.uploadedProgressFile);

    // Verify all segments have full source text
    const hasFullSource = progressData.segments.every(s => typeof s.source === 'string' && s.source.length > 0);
    if (!hasFullSource) {
      throw new Error('Progress file does not contain full source text. Please upload the original book file and use "Create Project" instead.');
    }

    statusEl.textContent = 'Reconstructing segments...';

    // Reconstruct full segment objects from progress data
    const segments = progressData.segments.map((ps, i) => ({
      id: i,
      source: ps.source,
      sourceHtml: ps.sourceHtml || '',
      status: ps.status || 'pending',
      translations: ps.translations || [],
      selectedIndex: ps.selectedIndex ?? -1,
      userFinal: ps.userFinal || '',
      previousOptions: ps.previousOptions || [],
      chapterId: ps.chapterId ?? 0,
      chapterTitle: ps.chapterTitle || 'All Segments',
      _meta: ps._meta || null,
    }));

    const modelId = document.getElementById('model-select').value;

    const project = {
      id: 'proj_' + Date.now(),
      name: document.getElementById('project-name').value || progressData.project?.name || 'Untitled',
      sourceLang: document.getElementById('source-lang').value || progressData.project?.sourceLang || 'en',
      targetLang: document.getElementById('target-lang').value || progressData.project?.targetLang || 'zh',
      modelId: modelId || progressData.project?.modelId || 'gpt-4o',
      createdAt: Date.now(),
      segments: segments,
      preferencePrompt: progressData.preferencePrompt || '',
      styleProfile: progressData.styleProfile || null,
      glossary: progressData.glossary || {},
      typographySettings: progressData.typographySettings || { ...AppState.typography },
      headingStyles: progressData.headingStyles || { ...AppState.headingStyles },
      coverImage: null,
      epubToc: [],
      epubMetadata: {},
    };

    if (progressData.typographySettings) {
      Object.assign(AppState.typography, progressData.typographySettings);
    }
    if (progressData.paraSettings) {
      AppState.paraSettings = { ...progressData.paraSettings };
    }
    if (progressData.headingStyles) {
      AppState.headingStyles = { ...AppState.headingStyles, ...progressData.headingStyles };
    }

    await dbPut(STORE_PROJECTS, project);
    AppState.project = project;
    AppState.projectId = project.id;
    AppState.confirmedCount = segments.filter(s => s.status === 'completed').length;
    AppState.currentSegmentIndex = segments.findIndex(s => s.status !== 'completed');
    if (AppState.currentSegmentIndex < 0) AppState.currentSegmentIndex = 0;

    // Import preference records
    if (progressData.preferences && progressData.preferences.length > 0) {
      for (const pref of progressData.preferences) {
        await dbPut(STORE_PREFS, { ...pref, projectId: project.id });
      }
    }

    localStorage.setItem('transloom_lastProject', project.id);

    const completed = segments.filter(s => s.status === 'completed').length;
    showToast(`Resumed directly — ${completed}/${segments.length} segments already translated`, 'success');

    const allDone = segments.every(s => s.status === 'completed');
    goToPhase(allDone ? 3 : 2);
  } catch (err) {
    showToast('Resume failed: ' + err.message, 'error');
    btn.disabled = false;
    btn.innerHTML = '<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg> Resume Directly (skip book upload)';
    statusEl.textContent = '';
  }
}

async function checkForExistingProject() {
  const lastId = localStorage.getItem('transloom_lastProject');
  if (lastId) {
    try {
      const project = await dbGet(STORE_PROJECTS, lastId);
      if (project) {
        document.getElementById('restore-banner').classList.remove('hidden');
        document.getElementById('restore-btn').onclick = () => restoreProject(project);
        document.getElementById('discard-btn').onclick = () => {
          document.getElementById('restore-banner').classList.add('hidden');
          localStorage.removeItem('transloom_lastProject');
        };
      }
    } catch (e) { console.warn(e); }
  }
}

async function restoreProject(project) {
  AppState.project = project;
  AppState.projectId = project.id;
  AppState.confirmedCount = project.segments.filter(s => s.status === 'completed').length;
  const firstPending = project.segments.findIndex(s => s.status !== 'completed');
  AppState.currentSegmentIndex = firstPending >= 0 ? firstPending : 0;
  if (project.typographySettings) {
    Object.assign(AppState.typography, project.typographySettings);
  }
  if (project.headingStyles) {
    AppState.headingStyles = { ...AppState.headingStyles, ...project.headingStyles };
  }
  const allDone = project.segments.every(s => s.status === 'completed');
  goToPhase(allDone ? 3 : 2);
}

async function createProject() {
  if (!AppState.uploadedFile) {
    showToast('Please select a file first', 'warning');
    return;
  }

  const createBtn = document.getElementById('create-btn');
  const statusEl = document.getElementById('create-status');
  createBtn.disabled = true;
  createBtn.textContent = 'Creating...';
  statusEl.textContent = 'Parsing document...';
  statusEl.classList.remove('hidden');

  try {
    const segments = await parseFile(AppState.uploadedFile);
    if (!segments || segments.length === 0) {
      throw new Error('No text content found in document. The file may be empty, DRM-protected, or use an unsupported internal format.');
    }
    // Filter out segments that are just whitespace
    const validSegments = segments.filter(s => s.source && s.source.trim().length > 0);
    if (validSegments.length === 0) {
      throw new Error('Document was parsed but no readable text was extracted. The file may be image-only or DRM-protected.');
    }
    // Re-index
    validSegments.forEach((s, i) => s.id = i);

    // Check if progress file matches — skip AI chapter detection if so
    const modelId = document.getElementById('model-select').value;
    let skipChapterDetection = false;

    if (AppState.uploadedProgressFile) {
      statusEl.textContent = 'Verifying against progress file...';
      try {
        const progressCheck = await importProgressFile(AppState.uploadedProgressFile);
        if (progressCheck.segments && progressCheck.segments.length > 0) {
          // Quick hash comparison: check a sample of segments
          const progSegs = progressCheck.segments;
          let matchCount = 0;
          const sampleSize = Math.min(validSegments.length, progSegs.length, 20);
          const step = Math.max(1, Math.floor(Math.min(validSegments.length, progSegs.length) / sampleSize));

          for (let i = 0; i < Math.min(validSegments.length, progSegs.length); i += step) {
            const newHash = computeSegmentHash(validSegments[i].source);
            if (progSegs[i] && progSegs[i].sourceHash === newHash) {
              matchCount++;
            }
          }

          const matchRatio = matchCount / Math.ceil(Math.min(validSegments.length, progSegs.length) / step);

          if (matchRatio >= 0.8 && Math.abs(validSegments.length - progSegs.length) <= 5) {
            // Segments match — reuse chapter structure from progress file, skip AI
            skipChapterDetection = true;
            for (let i = 0; i < validSegments.length && i < progSegs.length; i++) {
              if (progSegs[i].chapterId !== undefined) validSegments[i].chapterId = progSegs[i].chapterId;
              if (progSegs[i].chapterTitle) validSegments[i].chapterTitle = progSegs[i].chapterTitle;
            }
            statusEl.textContent = 'Segments verified — reusing existing structure...';
          } else {
            // Mismatch
            const proceed = confirm(
              `Segment mismatch detected:\n` +
              `Book has ${validSegments.length} segments, progress file has ${progSegs.length}.\n` +
              `Match rate: ${(matchRatio * 100).toFixed(0)}%.\n\n` +
              `This may mean the book file is different from the one used to create the progress file.\n\n` +
              `Click OK to proceed anyway (will try to match segments),\nor Cancel to abort and re-upload the correct file.`
            );
            if (!proceed) {
              throw new Error('File mismatch — please upload the correct book file.');
            }
          }
        }
      } catch (matchErr) {
        if (matchErr.message.includes('File mismatch')) throw matchErr;
        console.warn('Progress file pre-check failed, continuing with full creation:', matchErr);
      }
    }

    // Detect chapter structure using AI (skip if progress file matched or manual mode)
    if (!skipChapterDetection && AppState.aiProvider !== 'manual') {
      statusEl.textContent = 'Analyzing book structure (TOC, headings, links)...';
      try {
        await detectChaptersWithAI(validSegments, modelId);
      } catch (e) {
        console.warn('AI chapter detection failed, using fallback:', e);
        structuralFallbackGrouping(validSegments);
      }
    } else if (!skipChapterDetection) {
      // Manual mode without progress — use structural fallback (no AI)
      structuralFallbackGrouping(validSegments);
    }

    // Auto-assign heading levels from EPUB structural metadata and chapter boundaries
    const seenChapters = new Set();
    for (let i = 0; i < validSegments.length; i++) {
      const s = validSegments[i];
      const meta = s._meta;
      const cid = s.chapterId ?? 0;

      // Inherit heading tag from EPUB structure (h1-h4)
      if (meta && meta.headingTag && ['h1', 'h2', 'h3', 'h4'].includes(meta.headingTag)) {
        if (!AppState.paraSettings[i]) AppState.paraSettings[i] = {};
        AppState.paraSettings[i].heading = meta.headingTag;
      } else if (meta && (meta.hasHeadingStyle || meta.tocMatch)) {
        // Heading-styled text or TOC-matched text — mark as h3 by default
        if (!AppState.paraSettings[i]) AppState.paraSettings[i] = {};
        if (!AppState.paraSettings[i].heading) AppState.paraSettings[i].heading = 'h3';
      }

      // First segment of each chapter: add divider, promote to h2 if text matches title
      if (!seenChapters.has(cid)) {
        seenChapters.add(cid);
        const firstLine = s.source.split('\n')[0].trim();
        if (firstLine.length < 120 && (firstLine === s.chapterTitle || s.chapterTitle?.includes(firstLine))) {
          if (!AppState.paraSettings[i]) AppState.paraSettings[i] = {};
          AppState.paraSettings[i].heading = AppState.paraSettings[i].heading || 'h2';
          if (seenChapters.size > 1) AppState.paraSettings[i].divider = true;
        }
      }
    }

    // — Progress file restoration —
    let matchSummary = null;
    let progressData = null;
    if (AppState.uploadedProgressFile) {
      statusEl.textContent = 'Matching progress data...';
      try {
        progressData = await importProgressFile(AppState.uploadedProgressFile);
        const matchResults = matchProgressToSegments(validSegments, progressData);

        let exactCount = 0, fuzzyCount = 0, positionalCount = 0, unmatchedCount = 0, reviewCount = 0;

        for (let i = 0; i < validSegments.length; i++) {
          const m = matchResults[i];
          if (m.matchType === 'unmatched' || m.progressSegmentId === null) {
            unmatchedCount++;
            continue;
          }

          const progSeg = progressData.segments[m.progressSegmentId];
          if (progSeg.status === 'completed' && progSeg.userFinal) {
            validSegments[i].status = 'completed';
            validSegments[i].translations = progSeg.translations || [];
            validSegments[i].selectedIndex = progSeg.selectedIndex ?? -1;
            validSegments[i].userFinal = progSeg.userFinal;
            validSegments[i].previousOptions = progSeg.previousOptions || [];
          } else if (progSeg.status === 'active' && progSeg.translations && progSeg.translations.length > 0) {
            validSegments[i].status = 'active';
            validSegments[i].translations = progSeg.translations;
          }
          if (m.needsReview) {
            validSegments[i]._needsReview = true;
            reviewCount++;
          }

          if (m.matchType === 'exact') exactCount++;
          else if (m.matchType === 'fuzzy') fuzzyCount++;
          else if (m.matchType === 'positional') positionalCount++;
        }
        unmatchedCount = validSegments.length - exactCount - fuzzyCount - positionalCount;

        matchSummary = { exactCount, fuzzyCount, positionalCount, unmatchedCount, reviewCount, total: validSegments.length };
      } catch (e) {
        console.warn('Progress restoration failed:', e);
        showToast('Could not restore progress: ' + e.message, 'warning');
      }
    }

    // Clean up internal metadata (not needed for storage)
    // But preserve cover image and TOC for the editor
    const coverImage = validSegments._coverImage || null;
    const epubToc = validSegments._epubToc || [];
    const epubMetadata = validSegments._epubMetadata || {};
    for (const seg of validSegments) {
      delete seg._needsReview;
    }
    delete validSegments._epubToc;
    delete validSegments._structuredBlocks;
    delete validSegments._coverImage;
    delete validSegments._epubMetadata;

    // Auto-fill project name from EPUB metadata if not set by user
    const nameInput = document.getElementById('project-name');
    if (nameInput && !nameInput.value.trim() && epubMetadata.title) {
      nameInput.value = epubMetadata.title;
    }

    const project = {
      id: 'proj_' + Date.now(),
      name: document.getElementById('project-name').value || 'Untitled',
      sourceLang: document.getElementById('source-lang').value,
      targetLang: document.getElementById('target-lang').value,
      modelId: modelId,
      createdAt: Date.now(),
      segments: validSegments,
      preferencePrompt: progressData?.preferencePrompt || '',
      glossary: progressData?.glossary || {},
      typographySettings: progressData?.typographySettings || { ...AppState.typography },
      headingStyles: progressData?.headingStyles || { ...AppState.headingStyles },
      coverImage: coverImage,
      epubToc: epubToc,
      epubMetadata: epubMetadata,
    };

    if (progressData?.typographySettings) {
      Object.assign(AppState.typography, progressData.typographySettings);
    }
    if (progressData?.paraSettings) {
      AppState.paraSettings = { ...progressData.paraSettings };
    }
    if (progressData?.headingStyles) {
      AppState.headingStyles = { ...AppState.headingStyles, ...progressData.headingStyles };
    }

    await dbPut(STORE_PROJECTS, project);
    AppState.project = project;
    AppState.projectId = project.id;
    AppState.confirmedCount = validSegments.filter(s => s.status === 'completed').length;
    AppState.currentSegmentIndex = validSegments.findIndex(s => s.status !== 'completed');
    if (AppState.currentSegmentIndex < 0) AppState.currentSegmentIndex = 0;

    // Import preference records
    if (progressData?.preferences && progressData.preferences.length > 0) {
      for (const pref of progressData.preferences) {
        await dbPut(STORE_PREFS, { ...pref, projectId: project.id });
      }
    }

    localStorage.setItem('transloom_lastProject', project.id);

    // Show match summary modal if progress was restored
    if (matchSummary) {
      statusEl.textContent = '';
      createBtn.textContent = 'Create Project';
      await showMatchSummaryModal(matchSummary);
    }

    const completed = validSegments.filter(s => s.status === 'completed').length;
    const msg = matchSummary
      ? `Project restored — ${completed} segments already translated`
      : `Project created with ${validSegments.length} segments`;
    showToast(msg, 'success');

    const allDone = validSegments.every(s => s.status === 'completed');
    goToPhase(allDone ? 3 : 2);
  } catch (err) {
    showToast('Error: ' + err.message, 'error');
    createBtn.disabled = false;
    createBtn.textContent = 'Create Project';
    statusEl.textContent = '';
  }
}

function showMatchSummaryModal(summary) {
  return new Promise((resolve) => {
    const modal = document.getElementById('match-modal');
    const body = document.getElementById('match-modal-body');

    const matchedTotal = summary.exactCount + summary.fuzzyCount + summary.positionalCount;
    const matchPct = Math.round((matchedTotal / summary.total) * 100);

    body.innerHTML = `
      <div class="text-sm text-ink-600 leading-relaxed">
        <p class="mb-3">Matched <strong class="text-ink-800">${matchedTotal}</strong> of <strong class="text-ink-800">${summary.total}</strong> segments (${matchPct}%)</p>
        <div class="space-y-1.5">
          <div class="flex items-center gap-2">
            <span class="w-2.5 h-2.5 rounded-full bg-green-400 shrink-0"></span>
            <span>Exact match: <strong>${summary.exactCount}</strong></span>
          </div>
          ${summary.fuzzyCount > 0 ? `<div class="flex items-center gap-2">
            <span class="w-2.5 h-2.5 rounded-full bg-amber-400 shrink-0"></span>
            <span>Fuzzy match: <strong>${summary.fuzzyCount}</strong> (${summary.reviewCount} need review)</span>
          </div>` : ''}
          ${summary.positionalCount > 0 ? `<div class="flex items-center gap-2">
            <span class="w-2.5 h-2.5 rounded-full bg-orange-400 shrink-0"></span>
            <span>Positional match: <strong>${summary.positionalCount}</strong></span>
          </div>` : ''}
          ${summary.unmatchedCount > 0 ? `<div class="flex items-center gap-2">
            <span class="w-2.5 h-2.5 rounded-full bg-ink-300 shrink-0"></span>
            <span>New/unmatched: <strong>${summary.unmatchedCount}</strong></span>
          </div>` : ''}
        </div>
        ${matchPct < 20 ? '<p class="mt-3 text-amber-600 text-xs font-medium">Warning: Very low match rate — this progress file may be for a different document.</p>' : ''}
      </div>`;

    modal.classList.remove('hidden');

    const proceed = () => { modal.classList.add('hidden'); resolve(); };
    document.getElementById('match-modal-proceed').onclick = proceed;
    document.getElementById('match-modal-cancel').onclick = () => {
      modal.classList.add('hidden');
      // Reset state — don't proceed, let user start fresh
      resolve();
    };
  });
}


// ============================================================
// SECTION: PHASE NAVIGATION
// ============================================================
function goToPhase(phase) {
  document.getElementById('phase1').classList.add('hidden');
  document.getElementById('phase2').classList.add('hidden');
  document.getElementById('phase3').classList.add('hidden');

  AppState.currentPhase = phase;

  const el = document.getElementById('phase' + phase);
  el.classList.remove('hidden');
  el.classList.add('phase-enter');
  setTimeout(() => el.classList.remove('phase-enter'), 400);

  if (phase === 2) { renderPhase2(); showKeyboardHint(); }
  if (phase === 3) renderPhase3();
}

// ============================================================
// SECTION: UI RENDERING - PHASE 2 (TRANSLATION WORKBENCH)
// ============================================================
function renderPhase2() {
  const p = AppState.project;
  if (!p) return;

  document.getElementById('p2-project-name').textContent = p.name;
  const srcLang = LANGUAGES.find(l => l.code === p.sourceLang);
  const tgtLang = LANGUAGES.find(l => l.code === p.targetLang);
  document.getElementById('p2-lang-badge').textContent = `${srcLang?.label || p.sourceLang} → ${tgtLang?.label || p.targetLang}`;
  document.getElementById('p2-source-lang-tag').textContent = srcLang?.label || p.sourceLang;

  // Restore draft if available
  const draft = restoreDraft();
  if (draft && draft.currentSegmentIndex >= 0 && draft.currentSegmentIndex < p.segments.length) {
    AppState.currentSegmentIndex = draft.currentSegmentIndex;
    AppState.selectedOptionIndex = draft.selectedOptionIndex;
  }

  renderSidebar();
  renderCurrentSegment();
  updateEditorButton();

  // Apply draft custom text after rendering
  if (draft) {
    if (draft.writeOwnVisible) {
      document.getElementById('p2-write-own').classList.remove('hidden');
    }
    if (draft.customText) {
      const customInput = document.getElementById('p2-custom-input');
      if (customInput) customInput.value = draft.customText;
    }
    if (draft.editedOptionText && AppState.selectedOptionIndex >= 0) {
      const editableEl = document.getElementById('editable-option');
      if (editableEl) editableEl.textContent = draft.editedOptionText;
    }
    updateConfirmButton();
  }
}

function renderSidebar() {
  const p = AppState.project;
  const segments = p.segments;
  const total = segments.length;
  const completed = segments.filter(s => s.status === 'completed').length;
  const pct = total > 0 ? Math.round((completed / total) * 100) : 0;

  document.getElementById('p2-progress-text').textContent = `${completed}/${total} — ${pct}%`;

  const bar = document.getElementById('p2-progress-bar');
  bar.innerHTML = segments.map((s, i) => {
    let cls = 'progress-seg';
    if (s.status === 'completed') cls += ' done';
    else if (i === AppState.currentSegmentIndex) cls += ' current';
    return `<div class="${cls}" title="Segment ${i + 1}"></div>`;
  }).join('');

  // Group segments by chapter
  const chapters = [];
  const chapterMap = {};
  for (let i = 0; i < segments.length; i++) {
    const s = segments[i];
    const cid = s.chapterId ?? 0;
    if (!chapterMap[cid]) {
      chapterMap[cid] = { id: cid, title: s.chapterTitle || `Section ${cid}`, segments: [] };
      chapters.push(chapterMap[cid]);
    }
    chapterMap[cid].segments.push({ seg: s, globalIndex: i });
  }

  const list = document.getElementById('p2-segment-list');

  // If only one chapter, render flat list
  if (chapters.length <= 1) {
    list.innerHTML = segments.map((s, i) => renderSegmentItem(s, i)).join('');
    return;
  }

  list.innerHTML = chapters.map(ch => {
    const chCompleted = ch.segments.filter(x => x.seg.status === 'completed').length;
    const chTotal = ch.segments.length;
    const chPct = chTotal > 0 ? Math.round((chCompleted / chTotal) * 100) : 0;
    const isCollapsed = AppState.collapsedChapters[ch.id] === true;
    const hasActive = ch.segments.some(x => x.globalIndex === AppState.currentSegmentIndex);

    return `<div class="chapter-group">
      <div class="chapter-header flex items-center gap-2 px-4 py-2.5 ${isCollapsed ? 'collapsed' : ''}" onclick="toggleChapter(${ch.id})">
        <svg class="chevron w-3 h-3 text-ink-400 shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
        <span class="text-xs font-semibold text-ink-700 truncate flex-1">${escapeHtml(ch.title)}</span>
        <span class="text-[9px] px-1.5 py-0.5 rounded-full ${chPct === 100 ? 'bg-green-100 text-green-700' : hasActive ? 'bg-blue-100 text-blue-700' : 'bg-ink-100 text-ink-400'} font-semibold shrink-0">${chCompleted}/${chTotal}</span>
      </div>
      <div class="chapter-body ${isCollapsed ? 'collapsed' : ''}" style="max-height: ${isCollapsed ? '0' : ch.segments.length * 60 + 'px'}">
        ${ch.segments.map(x => renderSegmentItem(x.seg, x.globalIndex)).join('')}
      </div>
    </div>`;
  }).join('');

  // Scroll the active segment into view
  requestAnimationFrame(() => {
    const activeEl = list.querySelector('.seg-item.active');
    if (activeEl) activeEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  });
}

function renderSegmentItem(s, i) {
  let cls = 'seg-item px-4 py-2.5 cursor-pointer';
  const hasUnconfirmedTranslations = s.status !== 'completed' && s.translations && s.translations.length > 0;
  if (i === AppState.currentSegmentIndex) cls += ' active';
  else if (s._needsReview) cls += ' needs-review';
  else if (s.status === 'completed') cls += ' completed';
  else if (hasUnconfirmedTranslations) cls += ' ready';
  const statusBadge = s._needsReview
    ? '<span class="text-[9px] px-1.5 py-0.5 rounded-full bg-amber-100 text-amber-700 font-semibold">Review</span>'
    : s.status === 'completed'
    ? '<span class="text-[9px] px-1.5 py-0.5 rounded-full bg-green-100 text-green-700 font-semibold">Done</span>'
    : i === AppState.currentSegmentIndex
      ? '<span class="text-[9px] px-1.5 py-0.5 rounded-full bg-blue-100 text-blue-700 font-semibold">Active</span>'
      : hasUnconfirmedTranslations
        ? '<span class="text-[9px] px-1.5 py-0.5 rounded-full bg-purple-100 text-purple-700 font-semibold">Ready</span>'
        : '<span class="text-[9px] px-1.5 py-0.5 rounded-full bg-ink-100 text-ink-400 font-semibold">Pending</span>';
  const preview = s.status === 'completed' && s.userFinal
    ? `<p class="text-[11px] ${s._needsReview ? 'text-amber-600' : 'text-green-600'} mt-0.5 truncate">${escapeHtml(truncate(s.userFinal, 45))}</p>` : '';

  return `<div class="${cls}" onclick="jumpToSegment(${i})">
    <div class="flex items-center justify-between gap-2">
      <span class="text-xs text-ink-500 font-mono shrink-0">#${i + 1}</span>
      <span class="text-xs text-ink-600 truncate flex-1">${escapeHtml(truncate(s.source, 40))}</span>
      ${statusBadge}
    </div>
    ${preview}
  </div>`;
}

function toggleChapter(chapterId) {
  AppState.collapsedChapters[chapterId] = !AppState.collapsedChapters[chapterId];
  renderSidebar();
}

function switchSidebarTab(tab) {
  AppState.activeSidebarTab = tab;
  document.querySelectorAll('[data-sidebar-tab]').forEach(el => {
    el.classList.toggle('active', el.dataset.sidebarTab === tab);
  });
  document.getElementById('p2-segment-list').classList.toggle('hidden', tab !== 'segments');
  document.getElementById('p2-translated-list').classList.toggle('hidden', tab !== 'translated');
  document.getElementById('p2-glossary-panel').classList.toggle('hidden', tab !== 'glossary');
  if (tab === 'translated') renderTranslatedTab();
  if (tab === 'glossary') renderGlossary();
}

function renderTranslatedTab() {
  const p = AppState.project;
  if (!p) return;
  const list = document.getElementById('p2-translated-list');
  const completedSegs = p.segments.filter(s => s.status === 'completed' && s.userFinal);

  if (completedSegs.length === 0) {
    list.innerHTML = '<div class="px-4 py-8 text-center text-xs text-ink-400">No translations confirmed yet.</div>';
    return;
  }

  list.innerHTML = `<div class="p-4 space-y-3">
    <div class="flex items-center justify-between mb-1">
      <span class="text-[10px] uppercase tracking-wider text-ink-400 font-semibold">${completedSegs.length} segments translated</span>
    </div>
    <div class="flex gap-2 mb-2">
      <button onclick="downloadTranslatedTXT()" class="flex-1 btn-secondary py-1.5 rounded-lg text-[10px] flex items-center justify-center gap-1">
        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/></svg>
        Download TXT
      </button>
      <button onclick="exportProgress()" class="flex-1 btn-secondary py-1.5 rounded-lg text-[10px] flex items-center justify-center gap-1">
        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"/></svg>
        Save .tlprog
      </button>
    </div>
    ${completedSegs.map(s => `
      <div class="bg-ink-50 rounded-lg p-3 border border-ink-100 cursor-pointer hover:border-ink-300 transition-colors" onclick="jumpToSegment(${s.id})">
        <div class="flex items-center justify-between mb-1">
          <span class="text-[9px] text-ink-400 font-mono">#${s.id + 1}</span>
          <span class="text-[9px] text-ink-300 truncate ml-2 max-w-[60%]">${escapeHtml(truncate(s.source, 30))}</span>
        </div>
        <p class="text-sm text-ink-700 leading-relaxed">${escapeHtml(s.userFinal)}</p>
      </div>
    `).join('')}
  </div>`;
}

async function downloadTranslatedTXT() {
  const p = AppState.project;
  if (!p) return;
  const text = p.segments
    .filter(s => s.status === 'completed' && s.userFinal)
    .map(s => s.userFinal)
    .join('\n\n');
  if (!text.trim()) { showToast('No translated text yet', 'warning'); return; }
  const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  await downloadBlob(blob, (p.name || 'translation') + '_partial.txt');
  showToast('TXT downloaded', 'success');
}

function copyAllTranslated() {
  const p = AppState.project;
  if (!p) return;
  const text = p.segments
    .filter(s => s.status === 'completed' && s.userFinal)
    .map(s => s.userFinal)
    .join('\n\n');
  navigator.clipboard.writeText(text).then(() => {
    showToast('All translated text copied', 'success');
  }).catch(() => {
    showToast('Copy failed', 'error');
  });
}

function updateEditorButton() {
  const allDone = AppState.project.segments.every(s => s.status === 'completed');
  const btn = document.getElementById('go-to-editor-btn');
  if (allDone || AppState.codeUnlock) {
    btn.classList.remove('hidden');
    btn.onclick = () => goToPhase(3);
    if (!allDone && AppState.codeUnlock) {
      btn.textContent = 'Open Editor (Partial)';
    } else {
      btn.textContent = 'Open Editor';
    }
  } else {
    btn.classList.add('hidden');
  }
}

function jumpToSegment(index) {
  saveDraft(); // Save current draft before navigating
  AppState.currentSegmentIndex = index;
  AppState.selectedOptionIndex = -1;
  renderSidebar();
  renderCurrentSegment();
  // Switch to segments tab when jumping
  if (AppState.activeSidebarTab !== 'segments') {
    switchSidebarTab('segments');
  }
}

function renderCurrentSegment() {
  const p = AppState.project;
  const idx = AppState.currentSegmentIndex;
  const seg = p.segments[idx];
  if (!seg) return;

  document.getElementById('p2-seg-counter').textContent = `Segment ${idx + 1} of ${p.segments.length}`;
  document.getElementById('p2-source-text').textContent = seg.source;

  document.getElementById('prev-seg-btn').disabled = idx === 0;
  document.getElementById('next-seg-btn').disabled = idx >= p.segments.length - 1;

  document.getElementById('p2-instruct-area').classList.add('hidden');
  document.getElementById('p2-compare-area').classList.add('hidden');
  document.getElementById('p2-write-own').classList.add('hidden');
  document.getElementById('p2-manual-mode').classList.add('hidden');
  // Reset custom input when navigating between segments
  const customInput = document.getElementById('p2-custom-input');
  if (customInput) customInput.value = '';
  const manualInput = document.getElementById('p2-custom-input-manual');
  if (manualInput) manualInput.value = '';

  const isManual = (AppState.aiProvider === 'manual');

  if (seg.status === 'completed') {
    renderCompletedSegment(seg);
  } else if (isManual) {
    // Manual mode: show copy-prompt UI instead of AI translation
    document.getElementById('p2-loading').classList.add('hidden');
    document.getElementById('p2-options-list').innerHTML = '';
    document.getElementById('p2-manual-mode').classList.remove('hidden');
    // Hide AI-specific action buttons in manual mode
    document.getElementById('regen-btn').classList.add('hidden');
    document.getElementById('regen-instruct-btn').classList.add('hidden');
    document.getElementById('batch-5-btn').classList.add('hidden');
    document.getElementById('batch-10-btn').classList.add('hidden');
  } else if (seg.translations.length > 0) {
    // If segment has a pre-selected index (e.g., from batch), apply it
    if (seg.selectedIndex >= 0 && AppState.selectedOptionIndex < 0) {
      AppState.selectedOptionIndex = seg.selectedIndex;
    }
    renderTranslationOptions(seg);
  } else {
    startTranslation(seg);
  }

  // Show/hide AI buttons based on mode
  if (!isManual) {
    document.getElementById('regen-btn').classList.remove('hidden');
    document.getElementById('regen-instruct-btn').classList.remove('hidden');
    document.getElementById('batch-5-btn').classList.remove('hidden');
    document.getElementById('batch-10-btn').classList.remove('hidden');
  }

  const hasHistory = seg.previousOptions && seg.previousOptions.length > 0;
  document.getElementById('compare-btn').classList.toggle('hidden', !hasHistory);

  updateConfirmButton();
}

function renderCompletedSegment(seg) {
  document.getElementById('p2-loading').classList.add('hidden');
  const list = document.getElementById('p2-options-list');
  list.innerHTML = `
    <div class="bg-white rounded-xl border-2 border-green-300 p-4">
      <div class="flex items-center justify-between mb-2">
        <div class="flex items-center gap-2">
          <svg class="w-4 h-4 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/></svg>
          <span class="text-xs text-green-600 font-semibold uppercase tracking-wider">Confirmed Translation</span>
        </div>
        <button onclick="editConfirmedSegment()" class="text-xs text-ink-400 hover:text-accent flex items-center gap-1 transition-colors">
          <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg>
          Edit
        </button>
      </div>
      <div id="confirmed-text-display" class="text-ink-800 leading-relaxed" style="font-size:15px;">${highlightGlossaryTerms(escapeHtml(seg.userFinal))}</div>
      <div id="confirmed-edit-area" class="hidden">
        <textarea id="confirmed-edit-input" class="w-full text-ink-800 leading-relaxed border border-ink-200 rounded-lg p-3 mt-2 focus:outline-none focus:border-accent resize-none" style="font-size:15px;" rows="4">${escapeHtml(seg.userFinal)}</textarea>
        <div class="flex gap-2 mt-2">
          <button onclick="saveConfirmedEdit()" class="btn-accent px-4 py-2 rounded-lg text-xs font-medium">Save</button>
          <button onclick="cancelConfirmedEdit()" class="btn-secondary px-4 py-2 rounded-lg text-xs">Cancel</button>
        </div>
      </div>
    </div>`;
}

function editConfirmedSegment() {
  document.getElementById('confirmed-text-display').classList.add('hidden');
  document.getElementById('confirmed-edit-area').classList.remove('hidden');
  document.getElementById('confirmed-edit-input').focus();
}

function cancelConfirmedEdit() {
  document.getElementById('confirmed-text-display').classList.remove('hidden');
  document.getElementById('confirmed-edit-area').classList.add('hidden');
}

async function saveConfirmedEdit() {
  const seg = AppState.project.segments[AppState.currentSegmentIndex];
  if (!seg) return;
  const newText = document.getElementById('confirmed-edit-input').value.trim();
  if (!newText) {
    showToast('Translation cannot be empty', 'warning');
    return;
  }
  seg.userFinal = newText;
  await saveProject();
  // Update preference record to reflect the edited translation
  await recordPreference(seg);
  showToast('Translation updated', 'success');
  renderCurrentSegment();
  renderSidebar();
  if (AppState.activeSidebarTab === 'translated') renderTranslatedTab();
}

function renderTranslationOptions(seg) {
  document.getElementById('p2-loading').classList.add('hidden');
  const list = document.getElementById('p2-options-list');

  const labels = ['Faithful', 'Natural', 'Creative'];
  list.innerHTML = seg.translations.map((t, i) => {
    const isSelected = AppState.selectedOptionIndex === i;
    const label = labels[i] || `Option ${i + 1}`;
    return `<div class="option-card rounded-xl p-4 ${isSelected ? 'selected' : ''}" onclick="handleOptionCardClick(event, ${i})">
      <div class="flex gap-3">
        <div class="flex-1 min-w-0">
          <span class="text-[10px] uppercase tracking-wider font-semibold ${isSelected ? 'text-accent' : 'text-ink-400'} block mb-2">${label}</span>
          <div class="${isSelected ? 'text-ink-800' : 'text-ink-600'} leading-relaxed text-sm select-text" ${isSelected ? 'contenteditable="true" id="editable-option"' : ''}>${isSelected ? escapeHtml(t) : highlightGlossaryTerms(escapeHtml(t))}</div>
        </div>
        <div class="flex flex-col items-center justify-center gap-2 shrink-0 pl-2">
          <button class="copy-btn text-ink-400 hover:text-ink-600 p-1 rounded" onclick="event.stopPropagation(); copyOptionText(${i}, this)" title="Copy text">
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2 2v8a2 2 0 002 2z"/></svg>
          </button>
          <div class="w-5 h-5 rounded-full border-2 ${isSelected ? 'border-accent bg-accent' : 'border-ink-300'} flex items-center justify-center">
            ${isSelected ? '<svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/></svg>' : ''}
          </div>
        </div>
      </div>
    </div>`;
  }).join('');

  if (seg.status === 'completed') {
    AppState.selectedOptionIndex = seg.selectedIndex;
  }

  // Attach draft save listener to editable option
  const editableEl = document.getElementById('editable-option');
  if (editableEl) {
    editableEl.addEventListener('input', scheduleDraftSave);
  }
}

function handleOptionCardClick(event, index) {
  // Don't select if user is selecting text or interacting with contenteditable
  const sel = window.getSelection();
  if (sel && sel.toString().trim().length > 0) return;
  // Don't select if clicking inside contenteditable that's already selected
  if (event.target.closest('[contenteditable="true"]')) return;
  selectOption(index);
}

function copyOptionText(index, btnEl) {
  const seg = AppState.project.segments[AppState.currentSegmentIndex];
  if (!seg || !seg.translations[index]) return;
  const text = seg.translations[index];
  navigator.clipboard.writeText(text).then(() => {
    btnEl.classList.add('copied');
    btnEl.innerHTML = '<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg>';
    setTimeout(() => {
      btnEl.classList.remove('copied');
      btnEl.innerHTML = '<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/></svg>';
    }, 1500);
    showToast('Copied to clipboard', 'info');
  }).catch(() => {
    // Fallback: select the text in the card
    const cards = document.querySelectorAll('.option-card');
    const card = cards[index];
    if (card) {
      const textEl = card.querySelector('.select-text');
      if (textEl) {
        const range = document.createRange();
        range.selectNodeContents(textEl);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
    }
  });
}

async function startTranslation(seg) {
  if (AppState.isGenerating) return;
  AppState.isGenerating = true;

  document.getElementById('p2-loading').classList.remove('hidden');
  document.getElementById('p2-options-list').innerHTML = '';
  document.getElementById('confirm-btn').disabled = true;

  try {
    const options = await generateTranslations(seg.source);
    seg.translations = options;
    seg.status = 'active';
    AppState.selectedOptionIndex = -1;
    await saveProject();
    renderTranslationOptions(seg);
    renderSidebar();
  } catch (err) {
    showToast('Translation failed: ' + err.message, 'error');
    document.getElementById('p2-loading').classList.add('hidden');
  } finally {
    AppState.isGenerating = false;
  }
}

function selectOption(index) {
  AppState.selectedOptionIndex = index;
  // Clear custom text when selecting an AI option — resolve priority conflict
  const customInput = document.getElementById('p2-custom-input');
  if (customInput) customInput.value = '';
  // Also collapse Write Own area
  document.getElementById('p2-write-own').classList.add('hidden');
  const seg = AppState.project.segments[AppState.currentSegmentIndex];
  renderTranslationOptions(seg);
  updateConfirmButton();
}

function updateConfirmButton() {
  const seg = AppState.project.segments[AppState.currentSegmentIndex];
  const hasCustom = document.getElementById('p2-custom-input')?.value?.trim();
  const hasManual = document.getElementById('p2-custom-input-manual')?.value?.trim();
  const canConfirm = AppState.selectedOptionIndex >= 0 || hasCustom || hasManual;

  if (seg?.status === 'completed') {
    document.getElementById('confirm-btn').disabled = true;
    document.getElementById('confirm-btn').textContent = 'Confirmed \u2014 click Edit to revise';
  } else {
    document.getElementById('confirm-btn').disabled = !canConfirm;
    const isLast = AppState.currentSegmentIndex >= AppState.project.segments.length - 1;
    document.getElementById('confirm-btn').textContent = isLast ? 'Confirm & Finish' : 'Confirm & Next';
  }
}

async function confirmSegment() {
  const seg = AppState.project.segments[AppState.currentSegmentIndex];
  if (!seg) return;

  const customInput = document.getElementById('p2-custom-input');
  const customText = customInput?.value?.trim();
  const manualInput = document.getElementById('p2-custom-input-manual');
  const manualText = manualInput?.value?.trim();

  if (customText || manualText) {
    seg.userFinal = customText || manualText;
    seg.selectedIndex = -1;
  } else if (AppState.selectedOptionIndex >= 0) {
    const editableEl = document.getElementById('editable-option');
    const editedText = editableEl ? editableEl.textContent.trim() : seg.translations[AppState.selectedOptionIndex];
    seg.userFinal = editedText;
    seg.selectedIndex = AppState.selectedOptionIndex;
  } else {
    showToast('Please select or write a translation', 'warning');
    return;
  }

  seg.status = 'completed';

  // Capture confirmed segment reference before advancing index
  const confirmedSeg = seg;

  // Save project synchronously first
  await saveProject();

  showToast('Segment confirmed', 'success');
  clearDraft();

  // Advance to next segment BEFORE async preference recording
  if (AppState.currentSegmentIndex < AppState.project.segments.length - 1) {
    const prevChapterId = confirmedSeg.chapterId ?? 0;
    AppState.currentSegmentIndex++;
    AppState.selectedOptionIndex = -1;
    const nextSeg = AppState.project.segments[AppState.currentSegmentIndex];
    const nextChapterId = nextSeg?.chapterId ?? 0;

    // Auto-collapse completed chapter, auto-expand next chapter
    if (prevChapterId !== nextChapterId) {
      AppState.collapsedChapters[prevChapterId] = true;
      AppState.collapsedChapters[nextChapterId] = false;
    }

    renderSidebar();
    updateEditorButton();
    if (AppState.activeSidebarTab === 'translated') renderTranslatedTab();
    renderCurrentSegment();
  } else {
    renderSidebar();
    updateEditorButton();
    if (AppState.activeSidebarTab === 'translated') renderTranslatedTab();
    renderCurrentSegment();
    const allDone = AppState.project.segments.every(s => s.status === 'completed');
    if (allDone) {
      showToast('All segments translated! Opening editor...', 'success');
      setTimeout(() => goToPhase(3), 1200);
    }
  }

  // Record preference in background — does not block UI
  recordPreference(confirmedSeg).catch(e => console.warn('recordPreference failed:', e));
}

async function regenerate(instructions) {
  const seg = AppState.project.segments[AppState.currentSegmentIndex];
  if (!seg || AppState.isGenerating) return;

  if (seg.translations.length > 0) {
    seg.previousOptions.push([...seg.translations]);
  }

  seg.translations = [];
  seg.status = 'active';
  AppState.selectedOptionIndex = -1;
  AppState.isGenerating = true;

  document.getElementById('p2-loading').classList.remove('hidden');
  document.getElementById('p2-options-list').innerHTML = '';

  try {
    const options = await generateTranslations(seg.source, instructions);
    seg.translations = options;
    await saveProject();
    renderTranslationOptions(seg);
    renderSidebar();

    document.getElementById('compare-btn').classList.toggle('hidden', seg.previousOptions.length === 0);
  } catch (err) {
    showToast('Regeneration failed: ' + err.message, 'error');
  } finally {
    AppState.isGenerating = false;
    document.getElementById('p2-loading').classList.add('hidden');
  }
}

// ============================================================
// SECTION: BATCH TRANSLATION & REVIEW MODE
// ============================================================
let _batchCancelled = false;

async function batchTranslate(count) {
  if (AppState.isGenerating) {
    showToast('Translation already in progress', 'warning');
    return;
  }

  const segs = AppState.project.segments;
  // Find next pending segments starting from current
  const startIdx = AppState.currentSegmentIndex;
  const targets = [];
  for (let i = startIdx; i < segs.length && targets.length < count; i++) {
    if (segs[i].status !== 'completed') targets.push(i);
  }

  if (targets.length === 0) {
    showToast('No pending segments to translate', 'info');
    return;
  }

  _batchCancelled = false;
  AppState.isGenerating = true;

  // Show floating batch toast
  showBatchToast(targets.length);

  for (let ti = 0; ti < targets.length; ti++) {
    if (_batchCancelled) {
      showToast('Batch cancelled after ' + ti + ' segments', 'info');
      break;
    }

    const segIdx = targets[ti];
    const seg = segs[segIdx];

    updateBatchToast(ti + 1, targets.length);

    try {
      const options = await generateTranslations(seg.source, null, segIdx);
      seg.translations = options;
      seg.status = 'active';
      // Pre-select "Natural" option (index 1) as default suggestion
      seg.selectedIndex = options.length >= 2 ? 1 : 0;
      // Do NOT set seg.userFinal or seg.status = 'completed'
      // User must manually confirm each segment
      await saveProject();
    } catch (err) {
      console.warn('Batch: segment ' + segIdx + ' failed:', err);
      showToast('Segment #' + (segIdx + 1) + ' failed: ' + err.message, 'error');
    }

    renderSidebar();
  }

  AppState.isGenerating = false;
  dismissBatchToast();

  if (!_batchCancelled) {
    const readyCount = targets.filter(i => segs[i].translations && segs[i].translations.length > 0).length;
    showToast('Batch complete: ' + readyCount + ' segments ready for review', 'success');
    // Navigate to first batch-translated segment for manual confirmation
    const firstReady = targets.find(i => segs[i].translations && segs[i].translations.length > 0);
    if (firstReady !== undefined) {
      AppState.currentSegmentIndex = firstReady;
      AppState.selectedOptionIndex = segs[firstReady].selectedIndex >= 0 ? segs[firstReady].selectedIndex : -1;
    }
  }

  renderSidebar();
  renderCurrentSegment();
  updateEditorButton();
}

function showCompare() {
  const seg = AppState.project.segments[AppState.currentSegmentIndex];
  if (!seg || !seg.previousOptions || seg.previousOptions.length === 0) return;

  const area = document.getElementById('p2-compare-area');
  area.classList.toggle('hidden');

  if (!area.classList.contains('hidden')) {
    const content = document.getElementById('p2-compare-content');
    const prev = seg.previousOptions[seg.previousOptions.length - 1];
    content.innerHTML = prev.map((opt, i) => `
      <div class="bg-ink-50 rounded-lg p-3 border border-ink-100">
        <span class="text-[9px] uppercase text-ink-400 font-semibold">Previous Option ${i + 1}</span>
        <p class="text-ink-600 text-sm mt-1">${escapeHtml(opt)}</p>
      </div>
    `).join('') + `<div class="text-center text-xs text-ink-400 py-1">↕ Compare with current options above</div>`;
  }
}


// ============================================================
// SECTION: UI RENDERING - PHASE 3 (FULL BOOK EDITOR)
// ============================================================
function renderPhase3() {
  const p = AppState.project;
  if (!p) return;

  document.getElementById('p3-project-name').textContent = p.name;

  if (p.typographySettings) {
    Object.assign(AppState.typography, p.typographySettings);
  }
  if (p.headingStyles) {
    AppState.headingStyles = { ...AppState.headingStyles, ...p.headingStyles };
  }

  // Populate Book Info card
  const titleInput = document.getElementById('p3-book-title');
  if (titleInput) titleInput.value = p.name || '';

  // Cover thumbnail
  const coverThumb = document.getElementById('p3-cover-thumb');
  if (coverThumb && p.coverImage && p.coverImage.dataUrl) {
    coverThumb.innerHTML = `<img src="${p.coverImage.dataUrl}" alt="Cover" class="w-full h-full object-cover">`;
  } else if (coverThumb) {
    coverThumb.innerHTML = '<span class="text-ink-300 text-[10px]">No Cover</span>';
  }

  // Metadata stats
  const segs = p.segments || [];
  const translated = segs.filter(s => s.userFinal && s.userFinal.trim()).length;
  const progressPct = segs.length > 0 ? Math.round((translated / segs.length) * 100) : 0;
  const chapterIds = new Set(segs.map(s => s.chapterId ?? 0));

  const langEl = document.getElementById('p3-book-lang');
  if (langEl) langEl.textContent = p.targetLang || p.sourceLang || '-';
  const chapEl = document.getElementById('p3-book-chapters');
  if (chapEl) chapEl.textContent = chapterIds.size;
  const segEl = document.getElementById('p3-book-segments');
  if (segEl) segEl.textContent = segs.length;
  const progEl = document.getElementById('p3-book-progress');
  if (progEl) progEl.textContent = progressPct + '%';

  // EPUB metadata (creator/author)
  const meta = p.epubMetadata || {};
  const creatorRow = document.getElementById('p3-book-creator-row');
  const creatorEl = document.getElementById('p3-book-creator');
  if (creatorRow && creatorEl && meta.creator) {
    creatorRow.classList.remove('hidden');
    creatorEl.textContent = meta.creator;
  } else if (creatorRow) {
    creatorRow.classList.add('hidden');
  }

  syncTypographyControls();
  const hsLvlEl = document.getElementById('hs-level');
  if (hsLvlEl) {
    const lvl = hsLvlEl.value;
    const s = AppState.headingStyles[lvl] || {};
    document.getElementById('hs-font-size').value = s.fontSize || '1em';
    document.getElementById('hs-font-weight').value = s.fontWeight || '400';
    document.getElementById('hs-color').value = s.color || '#292524';
    document.getElementById('hs-align').value = s.textAlign || '';
    document.getElementById('hs-margin-top').value = s.marginTop || '0';
    document.getElementById('hs-margin-bottom').value = s.marginBottom || '0';
  }
  renderDocumentPreview();
}

function syncTypographyControls() {
  const t = AppState.typography;
  document.getElementById('typo-font').value = t.fontFamily;
  document.getElementById('typo-size').value = t.fontSize;
  document.getElementById('typo-lh').value = t.lineHeight;
  document.getElementById('typo-ls').value = t.letterSpacing;
  document.getElementById('typo-ps').value = t.paragraphSpacing;
  document.getElementById('typo-margin').value = t.pageMargin;

  document.querySelectorAll('.typo-align').forEach(btn => {
    const isActive = btn.dataset.align === t.textAlign;
    btn.classList.toggle('selected', isActive);
  });
}

function renderDocumentPreview() {
  const p = AppState.project;
  const doc = document.getElementById('p3-document');
  const t = AppState.typography;
  const hs = AppState.headingStyles || {};

  doc.style.fontFamily = t.fontFamily;
  doc.style.fontSize = t.fontSize + 'px';
  doc.style.lineHeight = t.lineHeight;
  doc.style.letterSpacing = t.letterSpacing + 'em';
  doc.style.textAlign = t.textAlign;
  doc.style.padding = t.pageMargin + 'rem';

  let html = '';

  // Cover image
  if (p.coverImage && p.coverImage.dataUrl) {
    html += `<div class="text-center mb-8"><img src="${p.coverImage.dataUrl}" alt="Cover" style="max-width:100%;max-height:60vh;margin:0 auto;border-radius:4px;box-shadow:0 2px 12px rgba(0,0,0,0.1);"></div>`;
  }

  // No auto-generated title or TOC — the book's own heading segments serve as natural structure

  // Build chapter map for anchors
  const chapterMap = {};
  for (let i = 0; i < p.segments.length; i++) {
    const s = p.segments[i];
    const cid = s.chapterId ?? 0;
    if (!chapterMap[cid]) chapterMap[cid] = i;
  }

  // Default heading inline styles
  const defaultHeadingStyles = {
    h1: 'font-size:2em;font-weight:700;',
    h2: 'font-size:1.5em;font-weight:600;',
    h3: 'font-size:1.25em;font-weight:600;',
    h4: 'font-size:1.1em;font-weight:600;',
    p: '',
  };

  // Build heading inline styles with user overrides
  function getHeadingStyle(tag) {
    const base = defaultHeadingStyles[tag] || '';
    const override = hs[tag];
    if (!override) return base;
    let s = base;
    if (override.fontSize) s = s.replace(/font-size:[^;]+;/, '') + `font-size:${override.fontSize};`;
    if (override.fontWeight) s = s.replace(/font-weight:[^;]+;/, '') + `font-weight:${override.fontWeight};`;
    if (override.color) s += `color:${override.color};`;
    if (override.marginTop) s += `margin-top:${override.marginTop};`;
    if (override.marginBottom) s += `margin-bottom:${override.marginBottom};`;
    if (override.textAlign) s += `text-align:${override.textAlign};`;
    return s;
  }

  // Render segments with chapter anchors
  let currentChapter = -1;
  html += p.segments.map((seg, i) => {
    let prefix = '';
    const cid = seg.chapterId ?? 0;
    if (cid !== currentChapter) {
      currentChapter = cid;
      prefix = `<a id="ch-${cid}"></a>`;
    }

    const ps = AppState.paraSettings[i] || {};
    const tag = ps.heading || 'p';
    const isSelected = AppState.selectedParaIndex === i;
    const dividerHtml = ps.divider ? '<hr class="border-ink-200 my-6">' : '';

    // Determine content: translated text, or rich sourceHtml, or plain source
    let content;
    if (seg.userFinal && seg.userFinal.trim()) {
      content = escapeHtml(seg.userFinal);
    } else if (seg.sourceHtml) {
      content = seg.sourceHtml;
    } else {
      content = escapeHtml(seg.source);
    }

    return `${prefix}${dividerHtml}<${tag} class="editor-para ${isSelected ? 'selected-para' : ''}" data-para-idx="${i}" style="margin-bottom:${t.paragraphSpacing}em;${getHeadingStyle(tag)}">${content}</${tag}>`;
  }).join('');

  doc.innerHTML = html;

  const customCss = document.getElementById('custom-css')?.value;
  let styleEl = document.getElementById('p3-custom-style');
  if (!styleEl) {
    styleEl = document.createElement('style');
    styleEl.id = 'p3-custom-style';
    document.head.appendChild(styleEl);
  }
  styleEl.textContent = customCss || '';

  doc.querySelectorAll('.editor-para').forEach(para => {
    para.addEventListener('click', (e) => {
      const idx = parseInt(para.dataset.paraIdx);
      selectParagraph(idx);
      e.stopPropagation();
    });
  });
}

function selectParagraph(index) {
  AppState.selectedParaIndex = index;
  renderDocumentPreview();

  const ps = AppState.paraSettings[index] || {};
  const hint = document.getElementById('p3-no-selection');
  if (hint) hint.classList.add('hidden');
  document.getElementById('para-heading').value = ps.heading || 'p';
  document.getElementById('para-divider').checked = !!ps.divider;
}

function applyTypography() {
  const t = AppState.typography;
  t.fontFamily = document.getElementById('typo-font').value;
  t.fontSize = parseFloat(document.getElementById('typo-size').value);
  t.lineHeight = parseFloat(document.getElementById('typo-lh').value);
  t.letterSpacing = parseFloat(document.getElementById('typo-ls').value);
  t.paragraphSpacing = parseFloat(document.getElementById('typo-ps').value);
  t.pageMargin = parseFloat(document.getElementById('typo-margin').value);

  if (AppState.project) {
    AppState.project.typographySettings = { ...t };
    saveProject();
  }
  renderDocumentPreview();
}

// ============================================================
// SECTION: POPUP AI EDITOR
// ============================================================
function initPopupEditor() {
  const preview = document.getElementById('p3-preview');
  if (!preview) return;

  preview.addEventListener('mouseup', (e) => {
    const selection = window.getSelection();
    if (!selection || selection.isCollapsed || selection.toString().trim().length === 0) return;

    const text = selection.toString().trim();
    if (text.length < 2) return;

    AppState.popupContext = {
      text: text,
      range: selection.getRangeAt(0).cloneRange(),
      paraEl: selection.anchorNode?.parentElement?.closest('.editor-para'),
    };

    showPopupEditor(e.clientX, e.clientY, text);
  });

  document.addEventListener('mousedown', (e) => {
    const popup = document.getElementById('popup-editor');
    if (!popup.contains(e.target) && !popup.classList.contains('hidden')) {
      closePopupEditor();
    }
  });
}

function showPopupEditor(x, y, text) {
  const popup = document.getElementById('popup-editor');
  popup.classList.remove('hidden');

  const vh = window.innerHeight;
  const vw = window.innerWidth;
  let top = y + 10;
  let left = x - 190;
  if (top + 350 > vh) top = y - 360;
  if (left < 10) left = 10;
  if (left + 380 > vw) left = vw - 390;

  popup.style.top = top + 'px';
  popup.style.left = left + 'px';

  document.getElementById('popup-selected-text').textContent = text;
  document.getElementById('popup-chat-input').value = '';
  document.getElementById('popup-suggestion').classList.add('hidden');
  document.getElementById('popup-loading').classList.add('hidden');
  document.getElementById('popup-chat-input').focus();
}

function closePopupEditor() {
  document.getElementById('popup-editor').classList.add('hidden');
  AppState.popupContext = null;
}

async function sendPopupChat() {
  const input = document.getElementById('popup-chat-input');
  const instruction = input.value.trim();
  if (!instruction || !AppState.popupContext) return;

  document.getElementById('popup-loading').classList.remove('hidden');
  document.getElementById('popup-suggestion').classList.add('hidden');

  try {
    const suggestion = await popupAIEdit(AppState.popupContext.text, instruction);
    document.getElementById('popup-suggestion-text').textContent = suggestion;
    document.getElementById('popup-suggestion').classList.remove('hidden');
    AppState.popupContext.suggestion = suggestion;
  } catch (err) {
    showToast('AI edit failed: ' + err.message, 'error');
  } finally {
    document.getElementById('popup-loading').classList.add('hidden');
  }
}

function acceptPopupSuggestion() {
  if (!AppState.popupContext?.suggestion || !AppState.popupContext.paraEl) return;

  const paraIdx = parseInt(AppState.popupContext.paraEl.dataset.paraIdx);
  const seg = AppState.project.segments[paraIdx];
  if (!seg) return;

  const oldText = AppState.popupContext.text;
  const newText = AppState.popupContext.suggestion;
  seg.userFinal = seg.userFinal.replace(oldText, newText);

  saveProject();
  renderDocumentPreview();
  closePopupEditor();
  showToast('Edit applied', 'success');

  recordPreference({
    id: seg.id,
    source: oldText,
    translations: [newText],
    userFinal: newText,
    status: 'completed',
    selectedIndex: 0,
    previousOptions: [],
  });
}

// ============================================================
// SECTION: GLOSSARY SYSTEM
// ============================================================
function addGlossaryEntry() {
  const srcInput = document.getElementById('glossary-source');
  const tgtInput = document.getElementById('glossary-target');
  const src = srcInput.value.trim();
  const tgt = tgtInput.value.trim();
  if (!src || !tgt) {
    showToast('Both source term and translation are required', 'warning');
    return;
  }
  if (!AppState.project.glossary) AppState.project.glossary = {};
  AppState.project.glossary[src] = tgt;
  saveProject();
  srcInput.value = '';
  tgtInput.value = '';
  srcInput.focus();
  renderGlossary();
  showToast(`Glossary: "${src}" → "${tgt}"`, 'success');

  // If the current active segment's source contains this glossary term, auto-regenerate
  const seg = AppState.project.segments[AppState.currentSegmentIndex];
  if (seg && seg.status !== 'completed' && seg.source.toLowerCase().includes(src.toLowerCase())) {
    showToast('Regenerating current segment with new glossary term...', 'info');
    regenerate();
  }

  // Ask user if they want to retroactively apply to existing translations
  showGlossaryRetroactiveModal(src, tgt);
}

function removeGlossaryEntry(src) {
  if (!AppState.project.glossary) return;
  delete AppState.project.glossary[src];
  saveProject();
  renderGlossary();
}

function renderGlossary() {
  const glossary = AppState.project?.glossary || {};
  const entries = Object.entries(glossary);
  const container = document.getElementById('glossary-entries');
  const emptyMsg = document.getElementById('glossary-empty');

  if (entries.length === 0) {
    container.innerHTML = '';
    emptyMsg.classList.remove('hidden');
    return;
  }

  emptyMsg.classList.add('hidden');
  container.innerHTML = entries.map(([src, tgt]) => `
    <div class="flex items-center gap-2 px-2.5 py-2 bg-ink-50 rounded-lg border border-ink-100 group">
      <span class="text-xs text-ink-700 font-medium flex-1 truncate">${escapeHtml(src)}</span>
      <span class="text-ink-300 text-xs">→</span>
      <span class="text-xs text-accent font-medium flex-1 truncate">${escapeHtml(tgt)}</span>
      <button onclick="removeGlossaryEntry(${JSON.stringify(src).replace(/"/g, '&quot;')})" class="text-ink-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-all p-0.5" title="Remove">
        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
      </button>
    </div>
  `).join('');

  // Add Scan & Replace button
  if (entries.length > 0) {
    container.innerHTML += `
      <div class="pt-2 border-t border-ink-100 mt-2">
        <button onclick="scanAndReplaceAllGlossary()" class="w-full btn-secondary py-2 rounded-lg text-[10px] font-medium flex items-center justify-center gap-1.5">
          <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
          Scan &amp; Replace All Glossary Terms
        </button>
      </div>`;
  }
}

async function exportGlossary() {
  const glossary = AppState.project?.glossary || {};
  if (Object.keys(glossary).length === 0) {
    showToast('No glossary entries to export', 'warning');
    return;
  }
  const data = {
    formatType: 'transloom-glossary',
    version: 1,
    sourceLang: AppState.project.sourceLang,
    targetLang: AppState.project.targetLang,
    entries: glossary,
    exportedAt: Date.now(),
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  await downloadBlob(blob, (AppState.project.name || 'glossary') + '.tlgloss');
  showToast('Glossary exported', 'success');
}

async function importGlossary(event) {
  const file = event.target.files[0];
  if (!file) return;
  try {
    const text = await file.text();
    const data = JSON.parse(text);
    let entries = {};
    if (data.entries && typeof data.entries === 'object') {
      entries = data.entries;
    } else if (typeof data === 'object' && !Array.isArray(data)) {
      // Plain {source: target} format
      entries = data;
    }
    const count = Object.keys(entries).length;
    if (count === 0) {
      showToast('No glossary entries found in file', 'warning');
      return;
    }
    if (!AppState.project.glossary) AppState.project.glossary = {};
    Object.assign(AppState.project.glossary, entries);
    await saveProject();
    renderGlossary();
    showToast(`Imported ${count} glossary entries`, 'success');
  } catch (e) {
    showToast('Import failed: ' + e.message, 'error');
  }
  event.target.value = '';
}

// ============================================================
// SECTION: EXPORT (TXT, DOCX, EPUB)
// ============================================================
function getExportTexts() {
  return AppState.project.segments
    .map((s, i) => ({ text: s.userFinal, globalIdx: i, seg: s }))
    .filter(item => item.text && item.text.trim());
}

async function exportTXT() {
  const items = getExportTexts();
  const content = items.map(item => item.text).join('\n\n');
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  await downloadBlob(blob, (AppState.project.name || 'translation') + '.txt');
  showToast('TXT exported', 'success');
}

async function exportDOCX() {
  try {
    const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = window.docx;
    const items = getExportTexts();
    const t = AppState.typography;

    const alignMap = {
      left: AlignmentType.LEFT,
      center: AlignmentType.CENTER,
      right: AlignmentType.RIGHT,
      justify: AlignmentType.JUSTIFIED,
    };

    const paragraphs = items.map((item) => {
      const ps = AppState.paraSettings[item.globalIdx] || {};
      const headingMap = {
        h1: HeadingLevel.HEADING_1,
        h2: HeadingLevel.HEADING_2,
        h3: HeadingLevel.HEADING_3,
        h4: HeadingLevel.HEADING_4,
      };

      const paraOpts = {
        children: [new TextRun({ text: item.text, size: t.fontSize * 2 })],
        alignment: alignMap[t.textAlign] || AlignmentType.LEFT,
        spacing: { after: Math.round(t.paragraphSpacing * 240) },
      };
      if (ps.heading && headingMap[ps.heading]) {
        paraOpts.heading = headingMap[ps.heading];
      }
      return new Paragraph(paraOpts);
    });

    const doc = new Document({
      sections: [{ children: paragraphs }],
    });

    const blob = await Packer.toBlob(doc);
    await downloadBlob(blob, (AppState.project.name || 'translation') + '.docx');
    showToast('DOCX exported', 'success');
  } catch (err) {
    showToast('DOCX export failed: ' + err.message, 'error');
  }
}

async function exportEPUB() {
  try {
    const zip = new JSZip();
    const p = AppState.project;
    const t = AppState.typography;
    const hs = AppState.headingStyles || {};
    const title = p.name || 'Translation';
    const bookId = 'transloom-' + Date.now();
    const lang = p.targetLang || 'en';
    const meta = p.epubMetadata || {};

    zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });

    zip.file('META-INF/container.xml',
      `<?xml version="1.0" encoding="UTF-8"?>\n<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container"><rootfiles><rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/></rootfiles></container>`);

    // Build heading CSS from AppState.headingStyles
    function hsCss(tag, defaults) {
      const s = hs[tag] || {};
      const fs = s.fontSize || defaults.fontSize;
      const fw = s.fontWeight || defaults.fontWeight;
      const c = s.color ? `color: ${s.color};` : '';
      const mt = s.marginTop || defaults.marginTop;
      const mb = s.marginBottom || defaults.marginBottom;
      const ta = s.textAlign ? `text-align: ${s.textAlign};` : '';
      return `${tag} { font-size: ${fs}; font-weight: ${fw}; margin: ${mt} 0 ${mb}; ${c} ${ta} }`;
    }

    const cssContent = [
      `body { font-family: ${t.fontFamily}; font-size: ${t.fontSize}px; line-height: ${t.lineHeight}; letter-spacing: ${t.letterSpacing}em; text-align: ${t.textAlign}; margin: ${t.pageMargin}rem; color: #292524; }`,
      `p { margin-bottom: ${t.paragraphSpacing}em; }`,
      hsCss('h1', { fontSize: '2em', fontWeight: '700', marginTop: '1em', marginBottom: '0.5em' }),
      hsCss('h2', { fontSize: '1.5em', fontWeight: '600', marginTop: '0.8em', marginBottom: '0.4em' }),
      hsCss('h3', { fontSize: '1.25em', fontWeight: '600', marginTop: '0.6em', marginBottom: '0.3em' }),
      hsCss('h4', { fontSize: '1.1em', fontWeight: '600', marginTop: '0.5em', marginBottom: '0.2em' }),
      `hr { border: none; border-top: 1px solid #d6d3d1; margin: 1.5em 0; }`,
    ].join('\n');
    zip.file('OEBPS/style.css', cssContent);

    // Group segments into chapters
    const chapters = [];
    const chapterMap = {};
    for (let i = 0; i < p.segments.length; i++) {
      const s = p.segments[i];
      const cid = s.chapterId ?? 0;
      if (!chapterMap[cid]) {
        chapterMap[cid] = { id: cid, title: s.chapterTitle || 'Section ' + (chapters.length + 1), segments: [] };
        chapters.push(chapterMap[cid]);
      }
      chapterMap[cid].segments.push({ seg: s, globalIdx: i });
    }

    // Resolve translated chapter titles
    for (const ch of chapters) {
      if (ch.segments.length > 0) {
        const firstSeg = ch.segments[0].seg;
        const firstIdx = ch.segments[0].globalIdx;
        const ps = AppState.paraSettings[firstIdx] || {};
        if (ps.heading && ps.heading !== 'p' && firstSeg.userFinal && firstSeg.userFinal.trim()) {
          ch.title = firstSeg.userFinal.split('\n')[0].trim();
        }
      }
    }

    if (chapters.length === 0) {
      chapters.push({ id: 0, title: title, segments: p.segments.map((s, i) => ({ seg: s, globalIdx: i })) });
    }

    // Cover image
    let coverMediaType = '';
    let coverFileName = '';
    if (p.coverImage && p.coverImage.dataUrl) {
      const match = p.coverImage.dataUrl.match(/^data:(image\/[^;]+);base64,(.+)$/);
      if (match) {
        coverMediaType = match[1];
        const ext = coverMediaType.split('/')[1].replace('jpeg', 'jpg');
        coverFileName = 'cover.' + ext;
        const binaryStr = atob(match[2]);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) bytes[i] = binaryStr.charCodeAt(i);
        zip.file('OEBPS/' + coverFileName, bytes);
      }
    }

    // Cover page XHTML
    if (coverFileName) {
      const coverXhtml = `<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml">\n<head><title>Cover</title><link rel="stylesheet" type="text/css" href="style.css"/></head>\n<body style="text-align:center;margin:0;padding:0;">\n<div style="height:100vh;display:flex;align-items:center;justify-content:center;">\n<img src="${coverFileName}" alt="Cover" style="max-width:100%;max-height:100vh;"/>\n</div>\n</body></html>`;
      zip.file('OEBPS/cover.xhtml', coverXhtml);
    }

    // Calculate translation progress
    const totalSegs = p.segments.length;
    const translatedSegs = p.segments.filter(s => s.userFinal && s.userFinal.trim()).length;
    const progressPct = totalSegs > 0 ? Math.round((translatedSegs / totalSegs) * 100) : 0;

    // Generate chapter XHTML files — exclude untranslated segments
    const chapterFiles = [];
    for (let ci = 0; ci < chapters.length; ci++) {
      const ch = chapters[ci];

      // Filter to only translated segments
      const translatedInChapter = ch.segments.filter(({ seg }) => seg.userFinal && seg.userFinal.trim());
      if (translatedInChapter.length === 0) continue; // Skip chapters with no translated content

      const fileName = `chapter${chapterFiles.length + 1}.xhtml`;
      chapterFiles.push({ id: `ch${chapterFiles.length + 1}`, fileName, title: ch.title });

      let bodyHtml = '';
      for (const { seg, globalIdx } of translatedInChapter) {
        const ps = AppState.paraSettings[globalIdx] || {};
        const tag = ps.heading || 'p';
        const text = seg.userFinal;
        if (ps.divider) bodyHtml += '<hr/>\n';
        bodyHtml += `<${tag}>${escapeHtml(text)}</${tag}>\n`;
      }

      const xhtml = `<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml">\n<head><title>${escapeHtml(ch.title)}</title><link rel="stylesheet" type="text/css" href="style.css"/></head>\n<body>\n${bodyHtml}</body></html>`;
      zip.file('OEBPS/' + fileName, xhtml);
    }

    // Colophon page
    const createdDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    const colophonHtml = `<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml">\n<head><title>Colophon</title><link rel="stylesheet" type="text/css" href="style.css"/></head>\n<body>\n<div style="margin-top:4em;text-align:center;color:#78716c;">\n<hr style="border:none;border-top:1px solid #d6d3d1;margin:0 auto 2em;width:30%;"/>\n<p style="font-size:0.85em;">Created with TransLoom</p>\n<p style="font-size:0.75em;">${escapeHtml(createdDate)}</p>\n<p style="font-size:0.75em;">Translation progress: ${progressPct}%</p>\n</div>\n</body></html>`;
    zip.file('OEBPS/colophon.xhtml', colophonHtml);

    // Build manifest items
    let manifestItems = `<item id="style" href="style.css" media-type="text/css"/>`;
    manifestItems += `<item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>`;
    if (coverFileName) {
      manifestItems += `<item id="cover-image" href="${coverFileName}" media-type="${coverMediaType}" properties="cover-image"/>`;
      manifestItems += `<item id="cover" href="cover.xhtml" media-type="application/xhtml+xml"/>`;
    }
    for (const cf of chapterFiles) {
      manifestItems += `<item id="${cf.id}" href="${cf.fileName}" media-type="application/xhtml+xml"/>`;
    }
    manifestItems += `<item id="colophon" href="colophon.xhtml" media-type="application/xhtml+xml"/>`;

    // Build spine
    let spineItems = '';
    if (coverFileName) spineItems += `<itemref idref="cover"/>`;
    for (const cf of chapterFiles) {
      spineItems += `<itemref idref="${cf.id}"/>`;
    }
    spineItems += `<itemref idref="colophon"/>`;

    // Build OPF metadata with EPUB metadata
    const modified = new Date().toISOString().replace(/\.\d+Z/, 'Z');
    let metadataXml = `<dc:identifier id="bookid">${bookId}</dc:identifier>\n<dc:title>${escapeHtml(title)}</dc:title>\n<dc:language>${lang}</dc:language>\n<meta property="dcterms:modified">${modified}</meta>`;
    if (meta.creator) metadataXml += `\n<dc:creator>${escapeHtml(meta.creator)}</dc:creator>`;
    if (meta.description) metadataXml += `\n<dc:description>${escapeHtml(meta.description)}</dc:description>`;
    if (meta.publisher) metadataXml += `\n<dc:publisher>${escapeHtml(meta.publisher)}</dc:publisher>`;

    const opf = `<?xml version="1.0" encoding="UTF-8"?>\n<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="bookid" version="3.0">\n<metadata xmlns:dc="http://purl.org/dc/elements/1.1/">\n${metadataXml}\n</metadata>\n<manifest>\n${manifestItems}\n</manifest>\n<spine>\n${spineItems}\n</spine>\n</package>`;
    zip.file('OEBPS/content.opf', opf);

    // Navigation document (EPUB3 nav)
    let tocOl = '';
    if (coverFileName) {
      tocOl += `<li><a href="cover.xhtml">Cover</a></li>\n`;
    }
    for (const cf of chapterFiles) {
      tocOl += `<li><a href="${cf.fileName}">${escapeHtml(cf.title)}</a></li>\n`;
    }

    const nav = `<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">\n<head><title>Navigation</title><link rel="stylesheet" type="text/css" href="style.css"/></head>\n<body>\n<nav epub:type="toc">\n<h1>Contents</h1>\n<ol>\n${tocOl}</ol>\n</nav>\n</body></html>`;
    zip.file('OEBPS/nav.xhtml', nav);

    const blob = await zip.generateAsync({ type: 'blob', mimeType: 'application/epub+zip' });
    await downloadBlob(blob, (p.name || 'translation') + '.epub');
    showToast('EPUB exported', 'success');
  } catch (err) {
    showToast('EPUB export failed: ' + err.message, 'error');
  }
}

async function downloadBlob(blob, filename) {
  // Try native File System Access API (showSaveFilePicker) first
  // This lets the user pick a real path and overwrite existing files
  if (window.showSaveFilePicker) {
    try {
      const ext = filename.includes('.') ? filename.split('.').pop() : '';
      const mimeMap = {
        'txt': 'text/plain', 'json': 'application/json', 'epub': 'application/epub+zip',
        'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'tlprog': 'application/json', 'tlgloss': 'application/json',
      };
      const types = ext ? [{
        description: ext.toUpperCase() + ' File',
        accept: { [mimeMap[ext] || 'application/octet-stream']: ['.' + ext] },
      }] : [];
      const handle = await showSaveFilePicker({ suggestedName: filename, types });
      const writable = await handle.createWritable();
      await writable.write(blob);
      await writable.close();
      return;
    } catch (err) {
      // User cancelled the picker or API failed — fall through to legacy download
      if (err.name === 'AbortError') return;
      console.warn('showSaveFilePicker failed, falling back:', err);
    }
  }

  // Legacy fallback: standard download
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

async function exportPreferences() {
  try {
    const prefs = await dbGetByIndex(STORE_PREFS, 'projectId', AppState.project.id);
    const data = {
      projectName: AppState.project.name,
      sourceLang: AppState.project.sourceLang,
      targetLang: AppState.project.targetLang,
      preferencePrompt: AppState.project.preferencePrompt,
      preferences: prefs,
      exportedAt: Date.now(),
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    await downloadBlob(blob, (AppState.project.name || 'prefs') + '_preferences.json');
    showToast('Preferences exported', 'success');
  } catch (e) {
    showToast('Export failed: ' + e.message, 'error');
  }
}

async function importPreferences(event) {
  const file = event.target.files[0];
  if (!file) return;
  try {
    const text = await file.text();
    const data = JSON.parse(text);
    if (data.preferencePrompt) {
      AppState.project.preferencePrompt = data.preferencePrompt;
      await saveProject();
      showToast('Preferences imported — style guide applied', 'success');
    } else {
      showToast('No preference data found in file', 'warning');
    }
  } catch (e) {
    showToast('Import failed: ' + e.message, 'error');
  }
  event.target.value = '';
}

// ============================================================
// SECTION: AI PROVIDER SETTINGS
// ============================================================
function onProviderChange() {
  const provider = document.getElementById('settings-ai-provider')?.value;
  const keyField = document.getElementById('api-key-field');
  const keyActions = document.getElementById('api-key-actions');
  const needsKey = (provider === 'openai' || provider === 'anthropic');
  if (keyField) keyField.classList.toggle('hidden', !needsKey);
  if (keyActions) keyActions.classList.toggle('hidden', !needsKey);
}

async function testApiKey() {
  const provider = document.getElementById('settings-ai-provider').value;
  const apiKey = document.getElementById('settings-api-key').value.trim();
  const resultEl = document.getElementById('api-test-result');

  if (!apiKey) {
    resultEl.textContent = 'Please enter an API key';
    resultEl.className = 'text-[10px] text-amber-500';
    return;
  }

  resultEl.textContent = 'Testing...';
  resultEl.className = 'text-[10px] text-ink-400';

  try {
    if (provider === 'openai') {
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + apiKey },
        body: JSON.stringify({ model: 'gpt-4o-mini', messages: [{ role: 'user', content: 'Say ok' }], max_tokens: 5 })
      });
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      resultEl.textContent = 'Connection successful';
      resultEl.className = 'text-[10px] text-green-600 font-medium';
    } else if (provider === 'anthropic') {
      const resp = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01',
          'anthropic-dangerous-direct-browser-access': 'true'
        },
        body: JSON.stringify({ model: 'claude-sonnet-4-20250514', max_tokens: 5, messages: [{ role: 'user', content: 'Say ok' }] })
      });
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      resultEl.textContent = 'Connection successful';
      resultEl.className = 'text-[10px] text-green-600 font-medium';
    }
  } catch (err) {
    resultEl.textContent = 'Failed: ' + err.message;
    resultEl.className = 'text-[10px] text-red-500';
  }
}

// ============================================================
// SECTION: MANUAL MODE PROMPT HELPERS
// ============================================================
function buildManualSystemPrompt() {
  const p = AppState.project;
  const prefPrompt = p.preferencePrompt || '';
  const prefSection = prefPrompt ? `\n[User Style Preferences]: ${prefPrompt}\n` : '';

  const glossary = p.glossary || {};
  const glossaryEntries = Object.entries(glossary);
  let glossarySection = '';
  if (glossaryEntries.length > 0) {
    glossarySection = '\n[Glossary — you MUST use these translations for the specified terms]:\n';
    for (const [src, tgt] of glossaryEntries) {
      glossarySection += `  "${src}" → "${tgt}"\n`;
    }
    glossarySection += '\n';
  }

  return `You are an expert literary translator from ${getSourceLangLabel()} to ${getTargetLangLabel()}.${prefSection}${glossarySection}
IMPORTANT: All proper nouns, character names, place names, and brand names MUST be kept in their original form — do NOT transliterate or translate them.

When translating, prioritize producing text that sounds like it was originally written in ${getTargetLangLabel()} by a native speaker. Avoid translationese — do not mirror the source grammar or word order when it would sound unnatural. Use idiomatic expressions, natural sentence rhythms, and culturally appropriate phrasing in ${getTargetLangLabel()}.

Provide exactly 3 different translation options:
1. A faithful/literal translation that preserves the original structure
2. A natural/fluent translation that reads smoothly and idiomatically in ${getTargetLangLabel()}, as if written by a native speaker
3. A creative/literary translation with stylistic flair and expressive language

Return ONLY valid JSON in this exact format (no markdown fences):
{"options": ["translation 1", "translation 2", "translation 3"]}`;
}

function buildManualTranslatePrompt() {
  const seg = AppState.project.segments[AppState.currentSegmentIndex];
  if (!seg) return '';
  return `Translate this text:\n\n${seg.source}`;
}

function copyManualSystemPrompt() {
  const prompt = buildManualSystemPrompt();
  navigator.clipboard.writeText(prompt).then(() => {
    showToast('System prompt copied to clipboard', 'success');
    const btn = document.getElementById('copy-system-prompt-btn');
    if (btn) {
      const orig = btn.innerHTML;
      btn.innerHTML = btn.innerHTML.replace('Copy System Prompt (first message)', 'Copied!');
      setTimeout(() => { btn.innerHTML = orig; }, 1500);
    }
  }).catch(() => {
    // Fallback: show in preview area
    const preview = document.getElementById('p2-manual-preview');
    if (preview) {
      preview.classList.remove('hidden');
      preview.querySelector('pre').textContent = prompt;
    }
    showToast('Could not copy — text shown below for manual copy', 'warning');
  });
}

function copyManualTranslatePrompt() {
  const prompt = buildManualTranslatePrompt();
  navigator.clipboard.writeText(prompt).then(() => {
    showToast('Translate prompt copied to clipboard', 'success');
    const btn = document.getElementById('copy-translate-prompt-btn');
    if (btn) {
      const orig = btn.innerHTML;
      btn.innerHTML = btn.innerHTML.replace('Copy Translate Prompt (this segment)', 'Copied!');
      setTimeout(() => { btn.innerHTML = orig; }, 1500);
    }
  }).catch(() => {
    const preview = document.getElementById('p2-manual-preview');
    if (preview) {
      preview.classList.remove('hidden');
      preview.querySelector('pre').textContent = prompt;
    }
    showToast('Could not copy — text shown below for manual copy', 'warning');
  });
}

// ============================================================
// SECTION: PLAIN TEXT COPY/PASTE ENFORCEMENT
// ============================================================
function enforcePlainTextPaste() {
  document.addEventListener('paste', (e) => {
    const el = e.target;
    if (el.contentEditable === 'true' || el.closest?.('[contenteditable="true"]')) {
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text/plain');
      document.execCommand('insertText', false, text);
    }
  });

  document.addEventListener('copy', (e) => {
    const el = e.target;
    if (el.contentEditable === 'true' || el.closest?.('[contenteditable="true"]')) {
      e.preventDefault();
      const selection = window.getSelection();
      if (selection) {
        e.clipboardData.setData('text/plain', selection.toString());
      }
    }
  });
}

// ============================================================
// SECTION: FLOATING BATCH PROGRESS TOAST
// ============================================================
function showBatchToast(totalCount) {
  let existing = document.getElementById('batch-float-toast');
  if (existing) existing.remove();

  const toast = document.createElement('div');
  toast.id = 'batch-float-toast';
  toast.className = 'batch-toast';
  toast.innerHTML = '<div class="flex items-center justify-between mb-2">' +
    '<span class="text-[10px] uppercase tracking-wider text-ink-400 font-semibold">Batch Translating</span>' +
    '<button id="batch-float-cancel" class="text-xs text-ink-400 hover:text-red-500 transition-colors">Cancel</button>' +
    '</div>' +
    '<div class="w-full bg-ink-100 rounded-full h-1.5 mb-1.5">' +
    '<div id="batch-float-bar" class="bg-accent h-1.5 rounded-full transition-all duration-300" style="width: 0%"></div>' +
    '</div>' +
    '<p id="batch-float-text" class="text-[10px] text-ink-500 text-center">Starting...</p>';
  document.body.appendChild(toast);
  document.getElementById('batch-float-cancel').onclick = () => { _batchCancelled = true; };
}

function updateBatchToast(current, total) {
  const bar = document.getElementById('batch-float-bar');
  const text = document.getElementById('batch-float-text');
  if (bar) bar.style.width = Math.round((current / total) * 100) + '%';
  if (text) text.textContent = 'Translating ' + current + ' of ' + total + '...';
}

function dismissBatchToast() {
  const toast = document.getElementById('batch-float-toast');
  if (toast) {
    toast.classList.add('dismissing');
    setTimeout(() => toast.remove(), 300);
  }
}

// ============================================================
// SECTION: GLOSSARY QUICK-ADD VIA TEXT SELECTION
// ============================================================
let _glossarySelectionData = null;

function showGlossaryFloatBtn(x, y, text, sourceOrTarget) {
  _glossarySelectionData = { text, sourceOrTarget };
  const btn = document.getElementById('glossary-float-btn');
  btn.classList.remove('hidden');
  btn.style.left = Math.min(x, window.innerWidth - 170) + 'px';
  btn.style.top = (y - 40) + 'px';
}

function hideGlossaryFloatBtn() {
  const btn = document.getElementById('glossary-float-btn');
  if (btn) btn.classList.add('hidden');
  _glossarySelectionData = null;
}

function addGlossaryFromSelection() {
  if (!_glossarySelectionData) return;
  const { text, sourceOrTarget } = _glossarySelectionData;
  hideGlossaryFloatBtn();

  if (sourceOrTarget === 'source') {
    document.getElementById('glossary-source').value = text;
    document.getElementById('glossary-target').value = '';
    switchSidebarTab('glossary');
    setTimeout(() => document.getElementById('glossary-target').focus(), 100);
  } else {
    document.getElementById('glossary-target').value = text;
    document.getElementById('glossary-source').value = '';
    switchSidebarTab('glossary');
    setTimeout(() => document.getElementById('glossary-source').focus(), 100);
  }
  showToast('Fill in the other field and click Add', 'info');
}

// ============================================================
// SECTION: GLOSSARY TERM HIGHLIGHTING
// ============================================================
function highlightGlossaryTerms(htmlText) {
  const glossary = AppState.project?.glossary || {};
  const entries = Object.entries(glossary);
  if (entries.length === 0) return htmlText;

  let result = htmlText;
  entries.forEach(([src, tgt], idx) => {
    const escapedTgt = escapeHtml(tgt).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    if (!escapedTgt) return;
    const regex = new RegExp('(' + escapedTgt + ')', 'gi');
    result = result.replace(regex,
      '<span class="glossary-term" title="Glossary #' + (idx + 1) + ': ' + escapeHtml(src) + ' → ' + escapeHtml(tgt) + '" style="text-decoration:underline;text-decoration-color:#a855f7;text-decoration-style:dotted;text-underline-offset:3px;">' +
      '<sup style="font-size:8px;color:#a855f7;margin-left:1px;">' + (idx + 1) + '</sup>$1</span>');
  });
  return result;
}

// ============================================================
// SECTION: GLOSSARY RETROACTIVE APPLY
// ============================================================
function showGlossaryRetroactiveModal(src, tgt) {
  const segs = AppState.project.segments;
  const matches = [];

  for (let i = 0; i < segs.length; i++) {
    const seg = segs[i];
    if (seg.status === 'completed' && seg.userFinal) {
      // Check if the glossary SOURCE term appears in the segment's SOURCE text
      const srcRegex = new RegExp(src.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      if (srcRegex.test(seg.source)) {
        matches.push({ index: i, text: seg.userFinal, source: seg.source });
      }
    }
  }

  if (matches.length === 0) {
    showToast('No completed segments contain "' + src + '" in their source text', 'info');
    return;
  }

  const modal = document.getElementById('glossary-retro-modal');
  document.getElementById('glossary-retro-desc').textContent =
    'Found "' + src + '" in the source text of ' + matches.length + ' completed segment(s). Replace with "' + tgt + '" in their translations?';

  const preview = document.getElementById('glossary-retro-preview');
  preview.innerHTML = matches.slice(0, 10).map(m =>
    '<div class="bg-ink-50 rounded-lg p-2 border border-ink-100 text-xs">' +
    '<span class="text-ink-400 font-mono">#' + (m.index + 1) + '</span> ' +
    '<span class="text-ink-500 ml-1">src: ' + escapeHtml(truncate(m.source, 50)) + '</span><br>' +
    '<span class="text-ink-600 ml-4">tgt: ' + escapeHtml(truncate(m.text, 60)) + '</span></div>'
  ).join('') + (matches.length > 10 ? '<p class="text-xs text-ink-400 text-center">...and ' + (matches.length - 10) + ' more</p>' : '');

  document.getElementById('glossary-retro-apply').onclick = async () => {
    closeGlossaryRetroModal();
    await applyGlossaryRetroactive(src, tgt, matches);
  };

  modal.classList.remove('hidden');
}

function closeGlossaryRetroModal() {
  document.getElementById('glossary-retro-modal').classList.add('hidden');
}

async function aiIdentifyAndReplace(sourceText, translatedText, glossarySrc, glossaryTgt) {
  const messages = [
    { role: 'system', content: `You are a translation correction assistant. Your task is to find and fix a specific term translation in the text below.

The source text contains the term "${glossarySrc}" which should be translated as "${glossaryTgt}".
However, the current translation may use a different (incorrect) translation for this term.

Your job:
1. Identify which word or phrase in the current translation corresponds to "${glossarySrc}" from the source
2. Replace ONLY that word/phrase with "${glossaryTgt}"
3. Keep everything else EXACTLY the same — do not rephrase, reorder, or change any other part of the translation

Return ONLY the corrected translation text, nothing else. No explanation, no quotes, no prefix.
If the translation already looks correct or you cannot identify the wrong term, return the original translation unchanged.` },
    { role: 'user', content: `Source text: ${sourceText}\n\nCurrent translation: ${translatedText}` },
  ];

  const response = await callAI(messages, { temperature: 0.1, maxTokens: 1000 });
  const result = (typeof response === 'string' ? response : String(response || '')).trim();
  // Sanity check: result should be similar length to original (not a completely different text)
  if (result.length > 0 && result.length < translatedText.length * 3 && result !== translatedText) {
    return result;
  }
  return translatedText;
}

async function applyGlossaryRetroactive(src, tgt, matches) {
  const segs = AppState.project.segments;
  let count = 0;
  let aiCount = 0;
  const needsAI = [];

  for (const m of matches) {
    const seg = segs[m.index];
    if (seg && seg.userFinal) {
      // Check if target term is already correct
      const tgtRegex = new RegExp(tgt.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      if (tgtRegex.test(seg.userFinal)) continue; // Already correct

      // Try literal replacement of source term in translation
      const regex = new RegExp(src.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      const before = seg.userFinal;
      seg.userFinal = seg.userFinal.replace(regex, tgt);
      if (seg.userFinal !== before) {
        count++;
      } else {
        // Source term not found literally in translation — needs AI to find the wrong translation
        needsAI.push(m);
      }
    }
  }

  // AI-assisted replacement for segments where literal match failed
  if (needsAI.length > 0 && AppState.aiProvider !== 'manual') {
    showToast(`Using AI to identify wrong translations in ${needsAI.length} segment(s)...`, 'info');
    for (const m of needsAI) {
      const seg = segs[m.index];
      try {
        const corrected = await aiIdentifyAndReplace(seg.source, seg.userFinal, src, tgt);
        if (corrected && corrected !== seg.userFinal) {
          seg.userFinal = corrected;
          aiCount++;
        }
      } catch (err) {
        console.warn('AI glossary replace failed for segment #' + (m.index + 1) + ':', err);
      }
    }
  } else if (needsAI.length > 0) {
    showToast(needsAI.length + ' segment(s) need manual review (AI unavailable in manual mode)', 'warning');
  }

  saveProject();
  renderSidebar();
  renderCurrentSegment();
  if (AppState.activeSidebarTab === 'translated') renderTranslatedTab();
  const total = count + aiCount;
  const msg = aiCount > 0
    ? `Replaced in ${total} segment(s) (${count} direct, ${aiCount} AI-assisted)`
    : `Replaced in ${total} segment(s)`;
  showToast(msg, total > 0 ? 'success' : 'info');
}

async function scanAndReplaceAllGlossary() {
  const glossary = AppState.project?.glossary || {};
  const entries = Object.entries(glossary);
  if (entries.length === 0) { showToast('No glossary entries', 'warning'); return; }

  const segs = AppState.project.segments;
  let directCount = 0;
  let aiCount = 0;
  const needsAI = []; // {segIndex, src, tgt}

  for (let si = 0; si < segs.length; si++) {
    const seg = segs[si];
    if (seg.status !== 'completed' || !seg.userFinal) continue;
    for (const [src, tgt] of entries) {
      // Check if the glossary SOURCE term appears in the segment's SOURCE text
      const srcRegex = new RegExp(src.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      if (!srcRegex.test(seg.source)) continue;
      // Check if target term is already correct in translation
      const tgtRegex = new RegExp(tgt.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      if (tgtRegex.test(seg.userFinal)) continue;
      // Try literal replacement of source term in translated text
      const wrongRegex = new RegExp(src.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      const before = seg.userFinal;
      seg.userFinal = seg.userFinal.replace(wrongRegex, tgt);
      if (seg.userFinal !== before) {
        directCount++;
      } else {
        // Needs AI to identify the wrong translation word
        needsAI.push({ segIndex: si, src, tgt });
      }
    }
  }

  // AI-assisted replacement for segments where literal match failed
  if (needsAI.length > 0 && AppState.aiProvider !== 'manual') {
    showToast(`Using AI to identify wrong translations in ${needsAI.length} case(s)...`, 'info');
    for (const item of needsAI) {
      const seg = segs[item.segIndex];
      try {
        const corrected = await aiIdentifyAndReplace(seg.source, seg.userFinal, item.src, item.tgt);
        if (corrected && corrected !== seg.userFinal) {
          seg.userFinal = corrected;
          aiCount++;
        }
      } catch (err) {
        console.warn('AI glossary replace failed for segment #' + (item.segIndex + 1) + ':', err);
      }
    }
  } else if (needsAI.length > 0) {
    showToast(needsAI.length + ' case(s) need manual review (AI unavailable in manual mode)', 'warning');
  }

  const total = directCount + aiCount;
  if (total > 0) {
    saveProject();
    renderSidebar();
    renderCurrentSegment();
    if (AppState.activeSidebarTab === 'translated') renderTranslatedTab();
  }
  const msg = aiCount > 0
    ? `Scan complete: ${total} replacement(s) (${directCount} direct, ${aiCount} AI-assisted)`
    : `Scan complete: ${total} replacement(s) made`;
  showToast(msg, total > 0 ? 'success' : 'info');
}

// ============================================================
// SECTION: SETTINGS PANEL
// ============================================================
function buildModelOptions(selectedModelId) {
  const premium = AI_MODELS.filter(m => m.tier === 'premium');
  const free = AI_MODELS.filter(m => m.tier === 'free');
  let html = '<optgroup label="Premium">';
  for (const m of premium) {
    const sel = selectedModelId === m.id ? ' selected' : '';
    const locked = !AppState.isPremium ? ' disabled' : '';
    const suffix = !AppState.isPremium ? ' \u{1F512}' : '';
    html += `<option value="${m.id}"${sel}${locked}>${m.label}${suffix}</option>`;
  }
  html += '</optgroup><optgroup label="Free">';
  for (const m of free) {
    const sel = selectedModelId === m.id ? ' selected' : '';
    html += `<option value="${m.id}"${sel}>${m.label}</option>`;
  }
  html += '</optgroup>';
  return html;
}

function toggleSettingsPanel() {
  const panel = document.getElementById('settings-panel');
  panel.classList.toggle('hidden');
  if (!panel.classList.contains('hidden')) {
    populateSettingsPanel();
  }
}

function populateSettingsPanel() {
  // Populate model selector
  const modelSel = document.getElementById('settings-model');
  modelSel.innerHTML = buildModelOptions(AppState.project?.modelId);

  // Premium status area
  const area = document.getElementById('premium-status-area');
  if (AppState.isPremium) {
    area.innerHTML = `
      <div class="flex items-center gap-2 h-[38px]">
        <span class="text-sm text-green-600 font-medium">Premium</span>
        <span class="text-[10px] px-2 py-1 rounded-full bg-accent text-white font-medium">Active</span>
        <button onclick="deactivatePremium()" class="text-[10px] text-ink-400 hover:text-red-500 ml-1 transition-colors">Deactivate</button>
      </div>`;
  } else {
    area.innerHTML = `
      <div class="space-y-1.5">
        <div class="flex items-center gap-2 h-[38px]">
          <span class="text-sm text-ink-600">Free</span>
          <span class="text-[10px] px-2 py-1 rounded-full border border-ink-200 text-ink-400 font-medium">Locked</span>
        </div>
        <div class="flex gap-1.5">
          <input type="text" id="premium-code-input" class="flex-1 px-2.5 py-1.5 rounded-lg border border-ink-200 text-xs font-mono focus:outline-none focus:border-accent placeholder:text-ink-300" placeholder="Enter premium code" autocomplete="off" spellcheck="false" onkeydown="if(event.key==='Enter')activatePremium()">
          <button onclick="activatePremium()" class="btn-accent px-3 py-1.5 rounded-lg text-[10px] font-medium whitespace-nowrap">Activate</button>
        </div>
      </div>`;
  }

  // Code Unlock
  document.getElementById('settings-code-unlock').checked = AppState.codeUnlock;

  // AI Provider
  const providerSel = document.getElementById('settings-ai-provider');
  if (providerSel) {
    providerSel.value = AppState.aiProvider || 'puter';
    onProviderChange();
  }
  const apiKeyInput = document.getElementById('settings-api-key');
  if (apiKeyInput) apiKeyInput.value = AppState.apiKey || '';
}

function updateProjectModel() {
  const modelId = document.getElementById('settings-model').value;
  if (AppState.project) {
    AppState.project.modelId = modelId;
    saveProject();
    showToast('Model updated to ' + AI_MODELS.find(m => m.id === modelId)?.label, 'info');
  }
}

// Premium code verification via SHA-256 hash
// The raw code is never stored in source — only its hash.
const _PREMIUM_HASH = '3699a9191263cbf0760075834f57f7956561ec511a352e0a8029cfda5b1fad4b';

async function _hashCode(code) {
  const normalized = code.trim().toUpperCase();
  const buf = new TextEncoder().encode(normalized);
  const hashBuf = await crypto.subtle.digest('SHA-256', buf);
  const arr = Array.from(new Uint8Array(hashBuf));
  return arr.map(b => b.toString(16).padStart(2, '0')).join('');
}

async function activatePremium() {
  return activatePremiumFrom('settings');
}

async function activatePremiumFrom(source) {
  const inputId = source === 'p1' ? 'p1-premium-code' : 'premium-code-input';
  const input = document.getElementById(inputId);
  if (!input) return;
  const code = input.value.trim();
  if (!code) {
    showToast('Please enter a premium code', 'warning');
    input.focus();
    return;
  }

  const hash = await _hashCode(code);
  if (hash === _PREMIUM_HASH) {
    AppState.isPremium = true;
    localStorage.setItem('transloom_premium', '1');
    localStorage.setItem('transloom_pv', hash.substring(0, 16));
    populateSettingsPanel();
    const p1Model = document.getElementById('model-select');
    if (p1Model) p1Model.innerHTML = buildModelOptions(null);
    updateP1PremiumUI();
    showToast('Premium activated', 'success');
  } else {
    input.value = '';
    input.classList.add('border-red-400');
    setTimeout(() => input.classList.remove('border-red-400'), 1500);
    showToast('Invalid code', 'error');
    input.focus();
  }
}

function deactivatePremium() {
  AppState.isPremium = false;
  localStorage.removeItem('transloom_premium');
  localStorage.removeItem('transloom_pv');
  populateSettingsPanel();
  const p1Model = document.getElementById('model-select');
  if (p1Model) p1Model.innerHTML = buildModelOptions(null);
  updateP1PremiumUI();
  showToast('Premium deactivated', 'info');
}

function toggleP1UnlockBox() {
  const box = document.getElementById('p1-unlock-box');
  if (box) {
    box.classList.toggle('hidden');
    if (!box.classList.contains('hidden')) {
      const input = document.getElementById('p1-premium-code');
      if (input) { input.value = ''; input.focus(); }
    }
  }
}

function updateP1PremiumUI() {
  const unlockArea = document.getElementById('p1-premium-unlock');
  if (!unlockArea) return;
  const link = document.getElementById('p1-unlock-link');
  const box = document.getElementById('p1-unlock-box');
  const active = document.getElementById('p1-premium-active');
  const manualOption = document.getElementById('p1-manual-mode-option');
  if (AppState.isPremium) {
    if (link) link.classList.add('hidden');
    if (box) box.classList.add('hidden');
    if (active) active.classList.remove('hidden');
    if (manualOption) manualOption.classList.remove('hidden');
    // Sync manual mode checkbox with stored provider
    const manualToggle = document.getElementById('p1-manual-toggle');
    if (manualToggle && AppState.aiProvider === 'manual') {
      manualToggle.checked = true;
      const modelDiv = document.getElementById('model-select')?.parentElement;
      if (modelDiv) { modelDiv.style.opacity = '0.4'; modelDiv.style.pointerEvents = 'none'; }
    }
  } else {
    if (link) link.classList.remove('hidden');
    if (active) active.classList.add('hidden');
    if (manualOption) manualOption.classList.add('hidden');
  }
}

function toggleP1ManualMode() {
  const checked = document.getElementById('p1-manual-toggle').checked;
  const modelDiv = document.getElementById('model-select').parentElement;
  if (checked) {
    AppState.aiProvider = 'manual';
    localStorage.setItem('transloom_ai_provider', 'manual');
    modelDiv.style.opacity = '0.4';
    modelDiv.style.pointerEvents = 'none';
  } else {
    AppState.aiProvider = 'puter';
    localStorage.setItem('transloom_ai_provider', 'puter');
    modelDiv.style.opacity = '';
    modelDiv.style.pointerEvents = '';
  }
}

function clearAllSessionData() {
  if (!confirm('This will clear your premium code, preferences, and all locally cached settings. Continue?')) return;
  localStorage.removeItem('transloom_premium');
  localStorage.removeItem('transloom_pv');
  localStorage.removeItem('transloom_code_unlock');
  localStorage.removeItem('transloom_draft');
  localStorage.removeItem('transloom_ai_provider');
  localStorage.removeItem('transloom_api_key');
  AppState.isPremium = false;
  AppState.codeUnlock = false;
  AppState.aiProvider = 'puter';
  AppState.apiKey = '';
  populateSettingsPanel();
  const p1Model = document.getElementById('model-select');
  if (p1Model) p1Model.innerHTML = buildModelOptions(null);
  updateP1PremiumUI();
  updateEditorButton();
  showToast('All session data cleared', 'info');
}

function toggleCodeUnlock() {
  AppState.codeUnlock = document.getElementById('settings-code-unlock').checked;
  localStorage.setItem('transloom_code_unlock', AppState.codeUnlock ? '1' : '0');
  updateEditorButton();
  showToast(AppState.codeUnlock ? 'Code Unlock enabled \u2014 editor accessible anytime' : 'Code Unlock disabled', 'info');
}

function saveSettings() {
  updateProjectModel();
  // Save AI provider settings
  const provider = document.getElementById('settings-ai-provider')?.value || 'puter';
  const apiKey = document.getElementById('settings-api-key')?.value?.trim() || '';
  AppState.aiProvider = provider;
  AppState.apiKey = apiKey;
  localStorage.setItem('transloom_ai_provider', provider);
  localStorage.setItem('transloom_api_key', apiKey);
  toggleSettingsPanel();
  showToast('Settings saved', 'success');
}

function loadSettings() {
  // Verify premium status: only trust if verification token exists
  const storedPremium = localStorage.getItem('transloom_premium') === '1';
  const storedPv = localStorage.getItem('transloom_pv') || '';
  AppState.isPremium = storedPremium && storedPv === _PREMIUM_HASH.substring(0, 16);
  AppState.codeUnlock = localStorage.getItem('transloom_code_unlock') === '1';
  AppState.aiProvider = localStorage.getItem('transloom_ai_provider') || 'puter';
  AppState.apiKey = localStorage.getItem('transloom_api_key') || '';
}

// ============================================================
// SECTION: KEYBOARD SHORTCUTS
// ============================================================
function toggleShortcutsPanel() {
  document.getElementById('shortcuts-panel').classList.toggle('hidden');
}

function isInputFocused() {
  const el = document.activeElement;
  if (!el) return false;
  const tag = el.tagName.toLowerCase();
  return tag === 'input' || tag === 'textarea' || tag === 'select' || el.contentEditable === 'true';
}

function initKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Ctrl+/ or Cmd+/ — toggle shortcuts panel
    if ((e.ctrlKey || e.metaKey) && e.key === '/') {
      e.preventDefault();
      toggleShortcutsPanel();
      return;
    }

    // Escape — close panels/modals
    if (e.key === 'Escape') {
      if (!document.getElementById('shortcuts-panel').classList.contains('hidden')) {
        toggleShortcutsPanel();
        return;
      }
      if (!document.getElementById('popup-editor').classList.contains('hidden')) {
        closePopupEditor();
        return;
      }
      const settings = document.getElementById('settings-panel');
      if (settings && !settings.classList.contains('hidden')) {
        toggleSettingsPanel();
        return;
      }
      return;
    }

    // Ctrl+S / Cmd+S — save progress
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      e.preventDefault();
      if (AppState.project) {
        saveProject();
        if (AppState.currentPhase === 3) {
          exportProgress();
        } else {
          showToast('Project saved', 'success');
        }
      }
      return;
    }

    // Skip shortcuts if typing in an input field
    if (isInputFocused()) return;

    // Phase 2 specific shortcuts
    if (AppState.currentPhase === 2) {
      const seg = AppState.project?.segments?.[AppState.currentSegmentIndex];

      // 1/2/3 — select option
      if (e.key === '1' && seg?.translations?.length >= 1) {
        e.preventDefault();
        selectOption(0);
        return;
      }
      if (e.key === '2' && seg?.translations?.length >= 2) {
        e.preventDefault();
        selectOption(1);
        return;
      }
      if (e.key === '3' && seg?.translations?.length >= 3) {
        e.preventDefault();
        selectOption(2);
        return;
      }

      // Enter — confirm segment (when not in an input)
      if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
        const canConfirm = AppState.selectedOptionIndex >= 0 || document.getElementById('p2-custom-input')?.value?.trim();
        if (canConfirm && seg?.status !== 'completed') {
          e.preventDefault();
          confirmSegment();
          return;
        }
      }

      // ArrowLeft — previous segment
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        if (AppState.currentSegmentIndex > 0) {
          saveDraft();
          AppState.currentSegmentIndex--;
          AppState.selectedOptionIndex = -1;
          renderSidebar();
          renderCurrentSegment();
        }
        return;
      }

      // ArrowRight — next segment
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        if (AppState.currentSegmentIndex < AppState.project.segments.length - 1) {
          saveDraft();
          AppState.currentSegmentIndex++;
          AppState.selectedOptionIndex = -1;
          renderSidebar();
          renderCurrentSegment();
        }
        return;
      }

      // R — regenerate
      if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        regenerate();
        return;
      }

      // W — write own (or edit confirmed)
      if (e.key === 'w' || e.key === 'W') {
        e.preventDefault();
        if (seg?.status === 'completed') {
          editConfirmedSegment();
          return;
        }
        document.getElementById('p2-write-own').classList.toggle('hidden');
        if (!document.getElementById('p2-write-own').classList.contains('hidden')) {
          const customInput = document.getElementById('p2-custom-input');
          customInput.value = '';
          customInput.focus();
        }
        return;
      }
    }
  });
}

// Show keyboard hint briefly when entering Phase 2
function showKeyboardHint() {
  const hint = document.getElementById('shortcuts-hint');
  if (!hint) return;
  hint.classList.remove('hidden');
  setTimeout(() => hint.classList.add('hidden'), 4000);
}

// ============================================================
// SECTION: EVENT BINDINGS & INITIALIZATION
// ============================================================
function bindPhase2Events() {
  document.getElementById('prev-seg-btn').addEventListener('click', () => {
    if (AppState.currentSegmentIndex > 0) {
      saveDraft();
      AppState.currentSegmentIndex--;
      AppState.selectedOptionIndex = -1;
      renderSidebar();
      renderCurrentSegment();
    }
  });
  document.getElementById('next-seg-btn').addEventListener('click', () => {
    if (AppState.currentSegmentIndex < AppState.project.segments.length - 1) {
      saveDraft();
      AppState.currentSegmentIndex++;
      AppState.selectedOptionIndex = -1;
      renderSidebar();
      renderCurrentSegment();
    }
  });
  document.getElementById('confirm-btn').addEventListener('click', confirmSegment);
  document.getElementById('regen-btn').addEventListener('click', () => regenerate());
  document.getElementById('regen-instruct-btn').addEventListener('click', () => {
    document.getElementById('p2-instruct-area').classList.toggle('hidden');
  });
  document.getElementById('p2-instruct-go').addEventListener('click', () => {
    const instr = document.getElementById('p2-instruct-input').value.trim();
    if (instr) {
      document.getElementById('p2-instruct-area').classList.add('hidden');
      regenerate(instr);
    }
  });
  document.getElementById('compare-btn').addEventListener('click', showCompare);
  document.getElementById('write-own-btn').addEventListener('click', () => {
    const seg = AppState.project?.segments?.[AppState.currentSegmentIndex];
    if (seg?.status === 'completed') {
      editConfirmedSegment();
      return;
    }
    document.getElementById('p2-write-own').classList.toggle('hidden');
    const customInput = document.getElementById('p2-custom-input');
    if (!document.getElementById('p2-write-own').classList.contains('hidden')) {
      customInput.value = '';  // Always start with a blank slate
      customInput.focus();
    }
  });

  document.getElementById('p2-custom-input')?.addEventListener('input', () => {
    updateConfirmButton();
    scheduleDraftSave();
  });

  // Glossary float button on text selection
  const p2Main = document.getElementById('p2-main');
  if (p2Main) {
    p2Main.addEventListener('mouseup', (e) => {
      setTimeout(() => {
        const sel = window.getSelection();
        const text = sel ? sel.toString().trim() : '';
        if (text.length > 0 && text.length < 200) {
          showGlossaryFloatBtn(e.clientX, e.clientY, text);
        } else {
          hideGlossaryFloatBtn();
        }
      }, 10);
    });
  }
  document.addEventListener('mousedown', (e) => {
    const fb = document.getElementById('glossary-float-btn');
    if (fb && !fb.contains(e.target)) hideGlossaryFloatBtn();
  });

  // Batch translation buttons
  document.getElementById('batch-5-btn').addEventListener('click', () => batchTranslate(5));
  document.getElementById('batch-10-btn').addEventListener('click', () => batchTranslate(10));

  // Manual mode prompt copy buttons
  document.getElementById('copy-system-prompt-btn').addEventListener('click', copyManualSystemPrompt);
  document.getElementById('copy-translate-prompt-btn').addEventListener('click', copyManualTranslatePrompt);

  // Manual mode input triggers confirm button update
  document.getElementById('p2-custom-input-manual')?.addEventListener('input', () => {
    updateConfirmButton();
    scheduleDraftSave();
  });
}

function stepInput(id, direction) {
  const input = document.getElementById(id);
  if (!input) return;
  const step = parseFloat(input.step) || 1;
  const min = parseFloat(input.min);
  const max = parseFloat(input.max);
  let val = parseFloat(input.value) + (step * direction);
  if (!isNaN(min)) val = Math.max(min, val);
  if (!isNaN(max)) val = Math.min(max, val);
  // Round to avoid floating point noise
  const decimals = (input.step.split('.')[1] || '').length;
  input.value = parseFloat(val.toFixed(decimals));
  input.dispatchEvent(new Event('input', { bubbles: true }));
}

function toggleExportDropdown() {
  const dd = document.getElementById('export-dropdown');
  if (dd) dd.classList.toggle('hidden');
}

function togglePrefsDropdown(phase) {
  const id = phase === 'p3' ? 'p3-prefs-dropdown' : 'prefs-dropdown';
  const dd = document.getElementById(id);
  if (dd) dd.classList.toggle('hidden');
  // Close when clicking outside
  if (dd && !dd.classList.contains('hidden')) {
    const close = (e) => {
      const container = dd.parentElement;
      if (!container.contains(e.target)) {
        dd.classList.add('hidden');
        document.removeEventListener('click', close);
      }
    };
    setTimeout(() => document.addEventListener('click', close), 0);
  }
}

function replaceBookCover(event) {
  const file = event.target.files[0];
  if (!file || !AppState.project) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    AppState.project.coverImage = { dataUrl: e.target.result, fileName: file.name };
    saveProject();
    // Update thumbnail
    const thumb = document.getElementById('p3-cover-thumb');
    if (thumb) thumb.innerHTML = `<img src="${e.target.result}" alt="Cover" class="w-full h-full object-cover">`;
    renderDocumentPreview();
  };
  reader.readAsDataURL(file);
}

function bindPhase3Events() {
  ['typo-font', 'typo-size', 'typo-lh', 'typo-ls', 'typo-ps', 'typo-margin'].forEach(id => {
    document.getElementById(id).addEventListener('input', applyTypography);
  });

  document.querySelectorAll('.typo-align').forEach(btn => {
    btn.addEventListener('click', () => {
      AppState.typography.textAlign = btn.dataset.align;
      applyTypography();
      syncTypographyControls();
    });
  });

  document.getElementById('para-heading').addEventListener('change', () => {
    if (AppState.selectedParaIndex < 0) return;
    if (!AppState.paraSettings[AppState.selectedParaIndex]) AppState.paraSettings[AppState.selectedParaIndex] = {};
    AppState.paraSettings[AppState.selectedParaIndex].heading = document.getElementById('para-heading').value;
    renderDocumentPreview();
  });

  document.getElementById('para-divider').addEventListener('change', () => {
    if (AppState.selectedParaIndex < 0) return;
    if (!AppState.paraSettings[AppState.selectedParaIndex]) AppState.paraSettings[AppState.selectedParaIndex] = {};
    AppState.paraSettings[AppState.selectedParaIndex].divider = document.getElementById('para-divider').checked;
    renderDocumentPreview();
  });

  document.getElementById('custom-css').addEventListener('input', renderDocumentPreview);

  // Heading style controls wiring
  const hsLevelSel = document.getElementById('hs-level');
  const hsFontSize = document.getElementById('hs-font-size');
  const hsFontWeight = document.getElementById('hs-font-weight');
  const hsColor = document.getElementById('hs-color');
  const hsAlign = document.getElementById('hs-align');
  const hsMarginTop = document.getElementById('hs-margin-top');
  const hsMarginBottom = document.getElementById('hs-margin-bottom');

  function syncHeadingStyleControls() {
    const lvl = hsLevelSel.value;
    const s = AppState.headingStyles[lvl] || {};
    hsFontSize.value = s.fontSize || '1em';
    hsFontWeight.value = s.fontWeight || '400';
    hsColor.value = s.color || '#292524';
    hsAlign.value = s.textAlign || '';
    hsMarginTop.value = s.marginTop || '0';
    hsMarginBottom.value = s.marginBottom || '0';
  }

  function applyHeadingStyleFromControls() {
    const lvl = hsLevelSel.value;
    AppState.headingStyles[lvl] = {
      fontSize: hsFontSize.value,
      fontWeight: hsFontWeight.value,
      color: hsColor.value === '#292524' ? '' : hsColor.value,
      textAlign: hsAlign.value,
      marginTop: hsMarginTop.value,
      marginBottom: hsMarginBottom.value,
    };
    if (AppState.project) {
      AppState.project.headingStyles = { ...AppState.headingStyles };
      saveProject();
    }
    renderDocumentPreview();
  }

  hsLevelSel.addEventListener('change', syncHeadingStyleControls);
  hsFontSize.addEventListener('change', applyHeadingStyleFromControls);
  hsFontWeight.addEventListener('change', applyHeadingStyleFromControls);
  hsColor.addEventListener('input', applyHeadingStyleFromControls);
  hsAlign.addEventListener('change', applyHeadingStyleFromControls);
  hsMarginTop.addEventListener('change', applyHeadingStyleFromControls);
  hsMarginBottom.addEventListener('change', applyHeadingStyleFromControls);

  syncHeadingStyleControls();

  // Book title change handler
  const bookTitleInput = document.getElementById('p3-book-title');
  if (bookTitleInput) {
    bookTitleInput.addEventListener('input', () => {
      if (AppState.project) {
        AppState.project.name = bookTitleInput.value;
        document.getElementById('p3-project-name').textContent = bookTitleInput.value;
        saveProject();
      }
    });
  }

  // Close export dropdown on outside click
  document.addEventListener('click', (e) => {
    const dd = document.getElementById('export-dropdown');
    const container = document.getElementById('export-dropdown-container');
    if (dd && container && !container.contains(e.target)) {
      dd.classList.add('hidden');
    }
  });

  document.getElementById('popup-send-btn').addEventListener('click', sendPopupChat);
  document.getElementById('popup-chat-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendPopupChat(); }
  });
  document.getElementById('popup-accept').addEventListener('click', acceptPopupSuggestion);
  document.getElementById('popup-reject').addEventListener('click', closePopupEditor);
  document.getElementById('popup-refine').addEventListener('click', () => {
    document.getElementById('popup-suggestion').classList.add('hidden');
    document.getElementById('popup-chat-input').value = '';
    document.getElementById('popup-chat-input').focus();
  });

  initPopupEditor();
}

async function init() {
  await openDB();
  loadSettings();
  initPhase1();
  updateP1PremiumUI();
  bindPhase2Events();
  bindPhase3Events();
  initKeyboardShortcuts();
  enforcePlainTextPaste();

  // Auto-save draft on page unload
  window.addEventListener('beforeunload', () => {
    saveDraft();
    if (AppState.project) {
      // Synchronous localStorage save of current segment index
      localStorage.setItem('transloom_lastSegment_' + AppState.project.id, String(AppState.currentSegmentIndex));
    }
  });

  // Periodic draft save while translating
  setInterval(() => {
    if (AppState.currentPhase === 2 && AppState.project) {
      saveDraft();
    }
  }, 10000);
}

document.addEventListener('DOMContentLoaded', init);
</script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"75124c326cb447fe934cde04713ae013","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"75124c326cb447fe934cde04713ae013","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"75124c326cb447fe934cde04713ae013","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"75124c326cb447fe934cde04713ae013","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>
